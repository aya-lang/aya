"Test file loaded!\n" .P

{```({ifstmtcondzN ifstmtthenz ifstmtelsez,
  {ifstmtelsez} {ifstmtthenz} ifstmtcondz?
})}:if;

.#? E assert L\n  Evaluates E as a list, throws an error if [E~] != L
{`({blkE expectedL,
  if ([blk] expected=) {
	  .# Do nothing
	} {
    .# Throw an error message about the assertation
	  ["assert " "blk".Z " = " expectedP  "\n\trecieved: " [blk]P]SP.D
	}
})}:assert;





.# Parsing and Literals

{1} assert [1]
{[1]} assert [[1]]
{['h'i]} assert ["hi"]

.# Basic Binary Math
{1 1 +} assert [2]
{5 4 *} assert [20]
{3 4 /} assert [0.75]
{1 1 -} assert [0]
{37 2%} assert [1]

.# Math Functions
{0.5 Mc} assert [(0.8775825618903728)]
{0.5 Ms} assert [(0.479425538604203)]
{0.5 Mt} assert [(0.5463024898437905)]
{0.5 MC} assert [(1.0471975511965979)]
{0.5 MS} assert [(0.5235987755982989)]
{0.5 MT} assert [(0.4636476090008061)]
{0.5 ML} assert [(-0.3010299956639812)]
{0.5 Ml} assert [(-0.6931471805599453)]
{0.5 Mq} assert [(0.7071067811865476)]

.# List

{6R} assert [[1 2 3 4 5 6]]
{3R#1+} assert [[2 3 4]]


.# Vectorized functions

{3R1+} assert [[2 3 4]]
{3R1-} assert [[0 1 2]]
{3R2*} assert [[2 4 6]]
{3R2/} assert [[0.5 1 1.5]]
{3R2^} assert [[1 4 9]]
{3R2%} assert [[1 0 1]]
{1 3R+} assert [[2 3 4]]
{1 3R-} assert [[0 (-1) (-2)]]
{2 3R*} assert [[2 4 6]]
{2 3R/} assert [[2 1 (2 3/)]]
{2 3R^} assert [[2 4 8]]
{2 3R%} assert [[0 0 2]]
{[0.5] Mc} assert [[(0.8775825618903728) ]]
{[0.5] Ms} assert [[(0.479425538604203)  ]]
{[0.5] Mt} assert [[(0.5463024898437905) ]]
{[0.5] MC} assert [[(1.0471975511965979) ]]
{[0.5] MS} assert [[(0.5235987755982989) ]]
{[0.5] MT} assert [[(0.4636476090008061) ]]
{[0.5] ML} assert [[(-0.3010299956639812)]]
{[0.5] Ml} assert [[(-0.6931471805599453)]]
{[0.5] Mq} assert [[(0.7071067811865476) ]]  

.# List Builder

{[3,]} assert [[1 2 3]]
{[3,1+]} assert [[2 3 4]]
{[4 6,]} assert [[4 5 6]]
{[0 0.5 2,]} assert [[0 0.5 1 1.5 2]]
{[10,,2%0=]} assert [[2 4 6 8 10]]
{[[1 2] [3 4], *]} assert [[3 8]]

.# Character

{'c!} assert ['C] 
{'C!} assert ['c]
{'?!} assert ['?]
{'A 1 +} assert ['B]
{'B 1 -} assert ['A]
{1 'A +} assert ['B]
{100 'A -} assert ['\#']

.# String

{"abcde"!} assert ["edcba"]

.# InterpolateString

{:a, 0:a; "$a"} assert ["0"]

.# Argument Types

{1  {sN,s} ~} assert [1]
{1  {sD,s} ~} assert [1]
{1Z {sF,s} ~} assert [1Z]
{[] {sL,s} ~} assert [[]]
{"" {sL,s} ~} assert [""]
{"" {sS,s} ~} assert [""]
{"hi" {sS,s} ~} assert ["hi"]
{"hi" {sL,s} ~} assert ["hi"]
{'C {sC,s} ~} assert ['C]
{1 'C "C" {aA bA cA,a b c} ~} assert [1 'C "C"]
{ {,} {dR,d}~} assert [{,}]

.# Dictionaries

{{,}}  assert [{,}]
{{,5 "hi" 'C}}  assert [{,}]
{{, 5:x}.x} assert [5]
{5 {,}.:x.x} assert [5]
{ {,{,5:x}:x;}.x.x} assert [5]
{ {,5:x} "x" N} assert [1]
{ {,5:x} "y" N} assert [0]


.# Objects 
{{, {self, self.x 2* self.:x}:double}:d; d!:p; 3p.:x; p.double.x}
assert
[6]

{{, {x y, {, x:x; y:y;} {, 3:z} MO }:new }:t; 3 4 t!:ta; ta.x ta.y ta.z}
assert
[3 4 3]


.# Operator Overloads
{ {,} {,{self, 2}:dollar;} MO $} assert [2]


.######
.# STD
.######


import "base/std"

{ if 1 1 2} assert [1]
{ if 0 {1} {2}} assert [2]
{ 0 then {1} } assert []
{ 1 then {2} } assert [2]
{:a,  3:a; dowhile {a 0 >} {aV:a;} a} assert [0] 
{:a,  0:a; dowhile {a 0 >} {aV:a;} a} assert [(-1)] 
{:a,  3:a; while {a 0 >} {aV:a;} a} assert [0] 
{:a,  0:a; while {a 0 >} {aV:a;} a} assert [0] 
{:a, 3R:a; for 'i a {iP} S } assert ["123"]
{try { 1 {} + } {2}} assert [2]
{try { 1 10 + } {2}} assert [11]
{1 2 3 count} assert [1 2 3 3]
{1 2 3 back} assert [1 2 3 1]
{ascii {islower} I} assert ["abcdefghijklmnopqrstuvwxyz"] 
{ascii {isdigit} I} assert ["0123456789"] 
{ascii {isupper} I} assert ["ABCDEFGHIJKLMNOPQRSTUVWXYZ"] 
{ascii {isupper} I #tolower} assert ["abcdefghijklmnopqrstuvwxyz"]
{ascii {islower} I #toupper} assert ["ABCDEFGHIJKLMNOPQRSTUVWXYZ"]
{["ab""cd""ef"] "_" join } assert ["ab_cd_ef"]
{["ab"] "_" join } assert ["ab"]
{"\n\r \tabc\n \t " trim} assert ["abc"]
{"hello" '7 10 strleftpad} assert ["77777hello"]
{"hello" '7 10 strrightpad} assert ["hello77777"]
{"a_b_c" tocamel} assert ["aBC"]
{1 [1 2 3] in} assert [1]
{4 [1 2 3] in} assert [0]
{[1 2 3] 1 ni} assert [1]
{[1 2 3] 4 ni} assert [0]
{4 8 range} assert [[4 5 6 7 8]]
{[[1 [2]][3]4] flatten} assert [[1 [ 2 ] 3 4]]
{"abc" "_" surround} assert ["_abc_"]
{[1 2 3][4 5 6]{+} zw} assert [[5 7 9]]
{ [[1 2 3][4 5 6]] transpose } assert [ [[ 1 4 ] [ 2 5 ] [ 3 6 ]] ]
{[6 2 9 7 2 6 5 3 3 4] rank} assert [ [ 3 9 1 2 9 3 5 7 7 6 ] ]
{1 {1+} 3 iter} assert [[1 2 3 4]]
{123 digits} assert [[1 2 3]]
{"hi" irange} assert [[0 1]]
{"ab""cd"{P+}pu#SS} assert ["cadacbdb"]
{[1 2 3 4] 0 1 swapitems} assert [ [ 2 1 3 4 ] ]
{1 10 3 linspace} assert [[1 5.5 10]]
{1 10 3 intspace} assert [[1 5 10]]
{[1 2 3] digitstonum} assert [123]
{[1 2 3 4] {3<} tw} assert [[1 2]]
{[1 1 1]allt} assert [1]
{[1 0 1]allt} assert [0]
{[0 0 0]allf} assert [1]
{[0 1 0]allf} assert [0]
{["a""b"]{E2=} any} assert [0]
{["a""bc"]{E2=} any} assert [1]
{["a""b"]{E1=} all} assert [1]
{["a""bc"]{E1=} all} assert [0]
{10 bits unbit} assert [10]

.#######
.# MATH
.#######

import "base/math"

{[3 (-3)] #abs} assert [[3 3]]
{[1 2 3] avg} assert [2]
{64Z cbrt} assert [4]
{1.4Z ceil} assert [2]
{90 deg} assert [pi 2 /]
{pi 2 / rad} assert [90]
{1 2 smaller} assert [1]
{1 2 bigger} assert [2]
{[1 2 3 4 5 6] cumsum} assert [[ 1 3 6 10 15 21 ]]
{[1 4 3 2 5] [2 5 3 1 4] pearson} assert [0.8]

.########
.# COLOR 
.######## 

import "base/colors"

{"2d2d5a" color.newhex} assert [45 45 90 color!]

import "base/constants"

import "base/dataframe"

import "base/data"

import "base/date"
import "base/dialog"
import "base/docs"
import "base/files"
import "base/golf"
import "base/queue"
import "base/set"
import "base/stack"

.# import "base/demo"

"All tests passed! ($(M$))\n" .P










