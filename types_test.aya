"running types test":P

list type F 1 :!

[[num]list T]list T:x;
[[num]list]list T :y;

x y :!

[[1 2][3 4]] x F 1 :!
[[1 2][3 4]] y F 1 :!

1 any  F 1 :!
"" any F 1 :!

.# basic types
"" str F 1 :!
1 str  F 0 :!


.# basic lists
[1 2 3] list F 1:!
[1 2 3] [any]listT F 1:!
[1 2 3] [num]listT F 1:!
[1 2 'c] [num]listT F 0:!


.# .# nested lists
[[1 2][3 4]] [[num]list]listT F 1 :!
[[1 2][3 4]] [list]listT F 1 :!
[[1 2][3 4]] [any]listT F 1 :!
[[1 2][3 4]] list F 1 :!
[[1 2]['c "d"]] [[num]list]listT F 0 :!
[[1 2]['c "d"]] [[any]list]listT F 1 :!
[[1 2]['c "d"]] [list]listT F 1 :!
[[1 2]['c "d"]] [any]listT F 1 :!
[[1 2]['c "d"]] [num]listT F 0 :!
[[1 2]['c "d"]] list F 1 :!

.# .# empty lists (always true)
[] [[num]list]listT F 1 :!
[] [[any]list]listT F 1 :!
[] [list]listT F 1 :!
[] [any]listT F 1 :!
[] [num]listT F 1 :!
[] list F 1 :!


.# .# unions
"" [str num]unionT F 1 :!
1 [str num]unionT F 1 :!
'c [str num]unionT F 0 :!
"" [str]unionT F 1 :!
1 [str]unionT F 0 :!

.# .# list/union combinations
[1 2 'c] [[num char]union]listT F 1 :!
1 [[num]list num]unionT F 1 :!
[1 2 3] [[num]list num]unionT F 1 :!
1 [[num]list num]unionT F 1 :!

.# .# dict
:{1:a} dict F 1 :!
:{1:a} [num]dictT F 1 :!
:{1:a} [str]dictT F 0 :!


struct foo {x} ;

.# new type format
def foo::__type__ :{
    ::foo:name;
    type.__meta__ :__meta__;
}



0 foo! foo F 1 :!
"foo" foo F 0 :!
foo type F 1 :!


struct point {x y} ;


.# new type format
def point::__type__ :{
    ::point:name;
    type.__meta__ :__meta__;
}

def point::__type_check__ {value inner self : inner_type, 
    inner.[0] :inner_type;

    value.x inner_type F
    value.y inner_type F
    &
}

1 2 point! point F 1 :!
"a" "b" point! point F 1 :!
1 2 point! [num]pointT F 1 :!
"a" "b" point! [num]pointT F 0 :!

point type F 1 :!


struct pair {first second} ;

def pair::__type__ :{
    ::pair :name;
    type.__meta__ :__meta__;
}

def pair::__type_check__ {value inner self,
    value.first  inner.[0] F
    value.second inner.[1] F
    &
}

1 2 pair! pair F 1 :!
1 "a" pair! pair F 1 :!
1 1 pair! [num num]pairT F 1 :!
1 "a" pair! [num str]pairT F 1 :!
1 1 pair! [str str]pairT F 0 :!
1 "a" pair! [str num]pairT F 0 :!

struct optional {value valid} ;

def optional::__type__ :{
    ::optional :name;
    type.__meta__ :__meta__;
}

def optional::__type_check__ {value inner self,
    value.valid {
        value.value inner.[0] F
    } {
        .# if empty, we don't care what the value is
        1
    } .?
}

"value" 1 optional! optional F 1 :!
"value" 1 optional! [str]optionalT F 1 :!
"value" 0 optional! [str]optionalT F 1 :!
.# invalid, we don't care what the inner type is
::value 0 optional! [str]optionalT F 1 :!
.# valid, we DO care what the inner type is
::value 1 optional! [str]optionalT F 0 :!
0 0 optional! [str]optionalT F 1 :!


((0 0 point!, 0 0 point!)pair!, 1)optional! [[[num]point [num]point]pair]optionalT F 1 :!
((0 "nope" point!, 0 0 point!)pair!, 1)optional! [[[num]point [num]point]pair]optionalT F 0 :!

"done" :P
