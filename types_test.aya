
"running types test":P
.# :{
    .# ::type :name;
.# }:type;
.# 
.#[:{::num:name}] :{::list:name}T .__meta__ :type;
0 0T :type;

.# :{
.#     .# When checking a type, the following will
.#     .# be checked in order from top to bottom
.# 
.#     .# 1. Any type
.#     .# If true, match with any type
.#     0 :any; .# ::bool
.# 
.#     0 :union;
.# 
.#     .# Must be overwritten
.#     .# :name;
.# 
.#     .# Container types
.#     .#For container types, the name must match AND the interal type must match
.#     .# list and dict have built in methods for checking
.#     .# for custom types, call:
.#     .#  value type.__type_check__
.#     .# custom types can implement custom type checking
.#     .# __type_check__ is implemented automatically by the struct keyword
.#     .# union implements a custom __type_check__ also
.#     .#[]:internal;
.# 
.# 
.#     type :__type__;
.# }:type_meta;
.# 
.# type_meta type.:__meta__;

type.__meta__ :type_meta;


:{
    ::any :name;
    1 :any;
    type_meta :__meta__;
}:any;

:{
    ::union:name;
    1:union;
    type_meta :__meta__;
} :union;

:{ ::num   :name; type_meta :__meta__; } :num;
:{ ::str   :name; type_meta :__meta__; } :str;
:{ ::char  :name; type_meta :__meta__; } :char;
:{ ::sym   :name; type_meta :__meta__; } :sym;
:{ ::block :name; type_meta :__meta__; } :block;
:{ ::list  :name; type_meta :__meta__; } :list;
:{ ::dict  :name; type_meta :__meta__; } :dict;


num 0 .M.:_type;
str "" .M.:_type;
char 'c .M.:_type;
sym ::_ .M.:_type;
block {} .M.:_type;
list [] .M.:_type;

{value::any type : value_type dict^,

    .# type may be a ::type or an ::object (i.e. point)
    .# the struct macro should be update so a point has type type
    .#   and an instance of a point has type point
    type ::object :@ {
        type.__type__ :type;
    } ?

    .# Here we need to get the type of the value
    .#The interpreter should generate this unless the object
    .#   is a dict that overloads the __type__ field
    .#   the logic is a bit messy here since we are implementing in aya
    value ::dict :@ {
        .# Value is a dict or object, if it has a __type__, use that
        .#   otherwise just use dict
        value ::__type__ H {
            value.__type__ :value_type;
        } {
            dict :value_type;
        } .?
    } {
        .# Value is not a dict or user object, get the _type
        .#    (this should be done internally by the interpreter)
        value._type :value_type;

        .# For built-ins, the original value is left on the stack
        .# pop it so it is consistent with user objects
        .#This should always be true since uer types are handled above
        [::num ::str ::char ::sym ::block ::list] value:T H 1 :!
        ;
    } .?

    {
        .# special case for classes
        .# interpreter should handle this differently
        ([{value ::object :@} {value :K ::__type__ H} {type ::name H} {type.name ::type}] {&}%) {
            1
        } (type.any) {
            1
        } (type.union) {
            .# Union: return true if any type in the union list matches
            type.inner :# {t : value^,
                value t type_check
            }
            {+}% 0> .# any
        } (type ::name H value_type ::name H & {type.name value_type.name =} &) {
            (type ::inner H) {
                .#There is an inner type specification, need to run custom type check
                {
                    .# List: Return true if
                    .#   the type is a list and all elements inside the list match the list type
                    (type.name ::list =) {:inner_type(type.inner.[0]),
                        type.inner E 1 :!

                        .# Check each element inside
                        value :# {e,
                            e inner_type type_check
                        }
                        {+}% value E = .# all
                    } 
                    
                    .# Custom generic types can override __type_check__
                    (type ::outer H {type.outer ::__type_check__ H} &) {
                        value type.inner type.outer.__type_check__
                    }
                    
                    .# Fallback: dict. Return true if
                    .#   all values inside the dict match the inner type (except __meta__)
                    {:inner_type(type.inner.[0]) all_correct_type(1) value^,
                        type.inner E 1 =! {bp}?
                        .# Check each element inside
                        value :# {k v : inner_type^,
                            k ::__meta__ = ! {
                                v inner_type type_check ! {
                                    .# Found a mismatch, set the flag to false
                                    0 :all_correct_type;
                                } ? 
                            } ?
                        }
                        all_correct_type
                    }
                } :?
            } {
                .# No inner type specification: match
                1
            } .?
        } {
        0
        }
    } :?
}:type_check;

{b val,
    {:b^ type_check^ val^, b type_check val} test.test
} :tc;


.#{inner::list type : outer,
.#    .# If inner has lists, recursively create types
.#    inner {:T::list=}O {+}% 0> { : buf(::nil) out([]),
.#        inner :# {x, 
.#            x :T ::list = {
.#                .# this entry is a list, save it to the buf
.#                .# if buf already has something (i.e. two lists in a row, error)
.#                buf ::nil :!
.#                x :buf;
.#            } {
.#                buf ::nil = {
.#                    .# previous entry was not a list, add as normal
.#                    x out.B; .# append
.#                } {
.#                    .# the previous entry was a list, recurse
.#                    buf x t out.B;
.#                    .# reset buf
.#                    ::nil :buf;
.#                } .?
.#            } .?
.#        };
.#        .# inner is now the fully assembled type
.#        out :inner;
.#    } ?
.#
.#    .# See note above in type_check
.#    type ::object :@ {
.#        type :outer;
.#        type.__type__ :type;
.#    } ?
.#
.#    type.name ::list = {
.#        innerE 1 :!
.#    } ?
.#    type.name ::dict = {
.#        innerE 1 :!
.#    } ?
.#    type.union {
.#        innerE 0 >  1:!
.#    } ?
.#
.#    :{
.#        inner:inner;
.#        type:__meta__;
.#        outer 0 =! {outer:outer;} ?
.#    }
.#}:t;

list type F 1 :!

[[num]list T]list T:x;
[[num]list]list T :y;

x y :!

[[1 2][3 4]] x F 1 :!
[[1 2][3 4]] y F 1 :!

1 any  F 1 :!
"" any F 1 :!

.# basic types
"" str F 1 :!
1 str  F 0 :!


.# basic lists
[1 2 3] list F 1:!
[1 2 3] [any]listT F 1:!
[1 2 3] [num]listT F 1:!
[1 2 'c] [num]listT F 0:!


.# .# nested lists
[[1 2][3 4]] [[num]list]listT F 1 :!
[[1 2][3 4]] [list]listT F 1 :!
[[1 2][3 4]] [any]listT F 1 :!
[[1 2][3 4]] list F 1 :!
[[1 2]['c "d"]] [[num]list]listT F 0 :!
[[1 2]['c "d"]] [[any]list]listT F 1 :!
[[1 2]['c "d"]] [list]listT F 1 :!
[[1 2]['c "d"]] [any]listT F 1 :!
[[1 2]['c "d"]] [num]listT F 0 :!
[[1 2]['c "d"]] list F 1 :!

.# .# empty lists (always true)
[] [[num]list]listT F 1 :!
[] [[any]list]listT F 1 :!
[] [list]listT F 1 :!
[] [any]listT F 1 :!
[] [num]listT F 1 :!
[] list F 1 :!


.# .# unions
"" [str num]unionT F 1 :!
1 [str num]unionT F 1 :!
'c [str num]unionT F 0 :!
"" [str]unionT F 1 :!
1 [str]unionT F 0 :!

.# .# list/union combinations
[1 2 'c] [[num char]union]listT F 1 :!
1 [[num]list num]unionT F 1 :!
[1 2 3] [[num]list num]unionT F 1 :!
1 [[num]list num]unionT F 1 :!

.# .# dict
:{1:a} dict F 1 :!
:{1:a} [num]dictT F 1 :!
:{1:a} [str]dictT F 0 :!


struct foo {x} ;

.# new type format
def foo::__type__ :{
    ::foo:name;
    type_meta :__meta__;
}



0 foo! foo F 1 :!
"foo" foo F 0 :!
foo type F 1 :!


struct point {x y} ;

.# new type format
def point::__type__ :{
    ::point:name;
    type_meta :__meta__;
}

def point::__type_check__ {value inner self : inner_type, 
    inner.[0] :inner_type;

    value.x inner_type type_check
    value.y inner_type type_check
    &
}

1 2 point! point F 1 :!
"a" "b" point! point F 1 :!
1 2 point! [num]pointT F 1 :!
"a" "b" point! [num]pointT F 0 :!

point type 1 tc


struct pair {first second} ;

def pair::__type__ :{
    ::pair :name;
    type_meta :__meta__;
}

def pair::__type_check__ {value inner self,
    value.first  inner.[0] type_check
    value.second inner.[1] type_check
    &
}

1 2 pair! pair F 1 :!
1 "a" pair! pair F 1 :!
1 1 pair! [num num]pairT F 1 :!
1 "a" pair! [num str]pairT F 1 :!
1 1 pair! [str str]pairT F 0 :!
1 "a" pair! [str num]pairT F 0 :!

struct optional {value valid} ;

def optional::__type__ :{
    ::optional :name;
    type_meta :__meta__;
}

def optional::__type_check__ {value inner self,
    value.valid {
        value.value inner.[0] type_check
    } {
        .# if empty, we don't care what the value is
        1
    } .?
}

"value" 1 optional! optional F 1 :!
"value" 1 optional! [str]optionalT F 1 :!
"value" 0 optional! [str]optionalT F 1 :!
.# invalid, we don't care what the inner type is
::value 0 optional! [str]optionalT F 1 :!
.# valid, we DO care what the inner type is
::value 1 optional! [str]optionalT F 0 :!
0 0 optional! [str]optionalT F 1 :!


((0 0 point!, 0 0 point!)pair!, 1)optional! [[[num]point [num]point]pair]optionalT F 1 :!
((0 "nope" point!, 0 0 point!)pair!, 1)optional! [[[num]point [num]point]pair]optionalT F 0 :!

"done" :P