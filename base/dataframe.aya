import "list"
import "file"

{,

  ::dataframe :type;

  {self, self.columns [1|~,.A]}:rows;

  {self,
	  [""] (self.columns_\;) K A
	  self.index #{P" |"K}
	  self.values
	  [2|~,.A]K
	  matstr
  }:repr:str;



  .#######################
  .# Creating Dataframes #
  .#######################

  {kwargs::dict : columns(::na) index(::na) data(::na) filename header(1) numofrows,
    kwargs .W

    filename :T ::str = {
      {, filename :filename
         header :header
         index ::na =! {index:index} ?
         columns ::na =! {columns:columns} ?
      } dataframe.opencsv
    } {
      {, data ::na =! {data :data} ?
         index ::na =! {index:index} ?
         columns ::na =! {columns:columns} ?
      } dataframe.fromdata
    } .?

  }:new;


  .# {colnm::list rownm::list cols::list : numofrows,

  .# Data is a list of lists (columns)
  {kwargs::dict : index(::na) columns(::na) data(::na) numofrows,
    kwargs .W

    data ::na = {
      0 [
        columns ::na = {1} {columns E} .? :c
        index ::na = {1} {index E} .?
        ] L :data :P
    } ?

    columns ::na = {
      data E dataframe.gencolnames :columns;
    } ?

    data E 0 = {
      .# no data -> empty dataframe
      0:numofrows;
    } {
      .# num of rows is first column length
      data 0 I E :numofrows;
    } .?

    .# if no index is given, generate one
    index ::na = {
      numofrows .R :index;
    } ?


    .# Additional checks

    data E columns E =! {
      "column names and given data lengths do not match" .D
    } ?

    numofrows index E =! {
      "row title lengths do not match numofrows: $numofrows, index length: $(index E)" .D
    } ?

    data #{E numofrows =} {&}F ! {
      "dataframe.fromdata: all row lengths must be equal" .D
    } ?


    {,
      columns :columns
      index :index
      data :values
      numofrows :numofrows
    } dataframe MO

  }:fromdata;


  .#? SBB dataframe.opencsv\n  open a csv file and create a dataframe\n  BB = rowheaders, colheaders
  {kwargs::dict : filename(::na) index(::na) columns(::na) header data,
    kwargs.W

    filename ::na = {
      "dataframe.opencsv: filename not provided" .D
    } ?

    filename opencsv :data;

    header {
      data E 0 = {"dataframe.opencsv: no header found in file" .D} ?
      data V :columns; ;
    } ?

    {,
      .# define only if they exist
      index ::na =! {index:index} ?
      columns ::na =! {columns:columns} ?

      .# opencsv returns a list of rows
      data .T :data
    }
    dataframe.fromdata
  }:opencsv;


  {[]__dataframe.new}:newempty;




  .############
  .# Indexing #
  .############

  .#? ::list ::dataframe dataframe.iloc\n  index a dataframe using row and col indices
  {i::list self : r c cols,
    i E 2 = ! {"dataframe.iloc: requires length 2 list. Recieved $i" .D} ?

    i 0 I :r;
    i 1 I :c;

    r :T ::num =
    c :T ::num = & {
      .# r and c are both numbers, return a value
      df.values c I r I

    } {

      .# r or c is a list, return a new dataframe

      df.values c I
      .# if c is a number, wrap in array
      c :T ::num = {A} ?
      .# if r is a number, wrap each in an array
      #{rI r :T ::num = {A} ?}
      :cols;

      {, cols :data;
         df.index r I r:T ::num = {A} ? :index;
         df.columns c I  c:T ::num = {A} ? :columns;
      } _:P dataframe!

    } .?

  }:iloc;

  




  {colname::str init::num self,
    self.colnames colnameAK self.:colnames;
    self.columns init self.numofrows LAK self.:columns;
  }:addcol;

  {rowname::str init self,
    self.rownames rownameAK self.:rownames;
    self.columns #{initAK} self.:columns;
    self.numofrowsB self.:numofrows;
  }:addrow;

  {self index::list: r c rix cix,
    "Index must have two elements" indexE2=! conderr
    index 0I:r;
    index 1I:c;

    .# Get row index
    [
      r:T ::str = {r self.rowindex} ?
      r :T ::num = r ?
      (-1)
    ].S:rix;

    .# Get column index
    [
      c:T ::str = {c self.colindex} ?
      c :T ::num = c ?
      (-1)
    ].S:cix;

    .# Get data
    [
      rix(-1)= cix(-1)=! & {self.columns cix I} ? .# Entire column
      rix(-1)=! cix(-1)= & {self.columns#{rixI}} ? .# Entire row
      rix(-1)=! cix(-1)=! & {self.columns cix I rix I} ? .# Specific cell
      {"dataframe: invalid index. recieved $index"}
    ].S
  }:getindex;

  {n,
    n 26 :< {
      ['a _nV+] R#P
    } {
      n 26- :n;
      "az"R#P
      n 26 .% 'a_@+K R "az"R {\P+} pu #~ n .< K
    } .?
  }:gencolnames;

  {column self : i,
    column self.colindex :i;
    self.rows {iI} .$ [1|~,.A] self.:columns;
    self
  }:sort;

}:dataframe;

.# ["total" "percent"] ["a" "b"] [[10 15][40 60]] dataframe!:df
