import "string"
import "list"
import "types"
import "math"

.{? type: matrix
    Matrix manipulations and representations
.}

{,

  .#? L<L> matrix.is\n  returns true if the list contains lists that are the same length and only contain numbers
  {m,
  .# Both of the following must be true:
  	m#.T{'L=}all .# The list is made up of only other lists
  	{
  		m#E{m0IE=}all 			.# All of the list lengths are the same
  	} 0 .?
  }:is;

  .# matrix constructor: first test if it is a valid matrix
  {in,
    in matrix.is
    {{,in:rows} matrix MO}
    {in P " is not a valid matrix" K .D}
    .?
  }:new;

  {.rows.E\0IEK}:dim; .#? (matrix) matrix.dim\n  return the dimention of the matrix\n  [#rows #cols]
  {m, m.rowsE m.rows#E\#= {|}F}:issq;          .#? (matrix) matrix.issq\n  returns true if the list is a square matrix
  {a b, [a.rows b.rows,[2|,+]] matrix!}:matadd;    .#? (matrix)(matrix) matrix.add\n  add two matrices
  {a b, [a.rows b.rows,[2|,-]] matrix!}:matsub;    .#? (matrix)(matrix) matrix.sub\n  subtract two matrices
  {m, [m.rows_ER,VI]}:tr;                       .#? (matrix) matrix.tr\n  trace of a matrix as a list
  {m, [m.rows~,.A] matrix!}:transpose;          .#? (matrix) matrix.transpose\n  transpose a matrix
  {[2|,*]S}:dot;                                .# dot product of two lists

  .#? N (matrix) matrix.pow\n  raise matrix to the Nth power
  {mat exp::num,
    "matrix.pow: exponent must be positive" exp1< conderr
    mat {_}expV%
    {.matmul}expV%
  }:pow;

  .#? (matrix) (matrix) matrix.matmul\n  multiply two matrices
  {a b,
    "matrix.mul: dimension mismatch $(a.c) != $(b.r)" a.c b.r =! conderr
    a.rows#{r, b.transpose.rows#{r matrix.dot}}
    matrix!
  }:matmul;

  .#? (matrix) (matrix) matrix.eq\n  test if two matrices are equal
  {a b,
     a.dim b.dim =! 0 {[a.rows b.rows,=]{&}F} .?
  }:eq;


  .# Elementary row operations

  .#? NN(matrix) rowmul\n  multiply row N2 by a scalar N1
  {n rn mat,
    (mat.rows rn :           .# Assign the rnth row of mat...
	  (mat.rows rn I #{n*})  .# ..to the rnth row times n
	  );
    mat
  }:rowmul;

  .# NN(matrix) rowswap\n swap rows N1 and N2 of the matrix
  {ra rb mat : tmp matrows,
    mat.rows :matrows;
    matrows ra I :tmp;            .# Store row N1 in a tmp var
	(matrows ra:(matrows rb I));  .# row N1 = row N2
	(matrows rb:(tmp));           .# row N2 = tmp
	mat
  }:rowswap;


  .# NNN (matrix) rowadd\n  add a N1*(N2nd row) to the N3rd row
  {add ra rb mat : tmp matrows,
    mat.rows :matrows;
    matrows ra I add #*:tmp;              .# Multiply the N2 row by N1
	 (matrows rb:([matrows rb I tmp, +])); .# Add the N2 row to N3
	mat
  }:rowadd;

  .# Augment
  {mata matb,
    "matrix.augment: both must have same number of rows" mata.r matb.r =! conderr
    [mata.rows matb.rows,K]matrix!
  }:augment;


  .# from rref
  .# invert
  .# rank
  .# det

  .# Indexing
  {n::num i::num j::num m, (m.rows iI j : (n));m}:set;      .#? NII (matrix) matrix.set\n  set the item at index I1, I2 to N
  {.rowsE}:r;                                   .#? (matrix) matrix.r\n  return the number of rows in the matrix
  {.rows0IE}:c;                                 .#? (matrix) matrix.r\n  return the number of cols in the matrix
  {.rows[1|~,.A]}:cols;                         .#? (matrix) matrix.cols\n  return the columns as a list of lists

  .{? (matrix) [row col] matrix.index\n  return the element at (r,c)
  if r is [], return the cth col
  if c is [], return the rth row .}
  {mat ix : r c,
    ix0I:r;
    ix1I:c;

    r[]=

    { .# row is empty []
      c[]=
      {
       .# both empty, return entire mat
       mat
      }
      {
        .# return col c
        mat.cols c I
      } .?
    }

    { .# row is an int
      c[]=
      {
        .# col empty, return entire row
        mat.rows r I
      }
      {
        .# col also int
        mat.rows r I c I
      } .?
    }

    .?

  }:index;



  .#Scalar Arithmetic
  {n::num m, m.rows #{n*} matrix!}:smul;     .#? N (matrix) matrix.smul\n  scalar multiplication
  {n::num m, m.rows #{n+} matrix!}:sadd;     .#? N (matrix) matrix.sadd\n  scalar addition
  {n::num m, m.rows #{n-} matrix!}:zsub;     .#? N (matrix) matrix.zsub\n  scalar subtraction (reversed)
  {n::num m, m.rows #{n\-} matrix!}:ssub;  .#? N (matrix) matrix.ssub\n  scalar subtraction
  {n::num m, m.rows #{n/} matrix!}:zdiv;     .#? N (matrix) matrix.zdiv\n  scalar division (reversed)
  {n::num m, m.rows #{n\/} matrix!}:sdiv;  .#? N (matrix) matrix.sdiv\n  scalar division

  .# OVERLOADS

  {a b,
    [
      a .T ::num = b .T'R = & {a b matrix.smul} ?
      b .T ::num = a .T'R = & {b a matrix.smul} ?
      aMw"DICT"= bMw"DICT"= & {a b matrix.matmul} ?
      {"matrix.star: invalid argument type. recieved: \n $a\n $b".D}
    ].S
  }:mul;

  {a b,
    [
      a .T ::num = b .T'R = & {a b matrix.sadd} ?
      b .T ::num = a .T'R = & {b a matrix.sadd} ?
      aMw"DICT"= bMw"DICT"= & {a b matrix.matadd} ?
      {"matrix.plus: invalid argument type. recieved: \n $a\n $b".D}
    ].S
  }:add;

  {a b,
    [
      a .T ::num = b .T'R = & {a b matrix.ssub} ?
      b .T ::num = a .T'R = & {b a matrix.zsub} ?
      aMw"DICT"= bMw"DICT"= & {a b matrix.matsub} ?
      {"matrix.minus: invalid argument type. recieved: \n $a\n $b".D}
    ].S
  }:sub;


  {a b,
    [
      a .T ::num = b .T'R = & {a b matrix.sdiv} ?
      b .T ::num = a .T'R = & {b a matrix.zdiv} ?
      {"matrix.fslash: invalid argument type. recieved: \n $a\n $b".D}
    ].S
  }:div;

  {mat expr,
    mat.rows#{#expr} mat.:rows;
    mat
  }:and;

  .#? (matrix) matrix.show\n  converts a matrix to a string
  {.rows matstr
    "\n"" |\n|"@.& .# Inside bars
    " |"K'|\K            .# Outside bars
    "\n"+
  }:repr;

  .#? N matrix.i\n  generate an Nd identity matrix
  {
    _0\L1\K\_KL {,}.:rows matrix MO
  }:eye;


  .#? S matrix.fopen\n  open a space-delimited file containing a matrix as a matrix object
  {G"\n"|#{" "|#~}matrix!}:fopen;

  .# generates the next row of a pascal matrix
  {prev::list : new len ix,
    prevE:len;
    1 0 lenVLK:new;
    1:ix;
    new {(ix:(prev ixI new ixVI+)) ixB:ix;}lenV%
  }:nextpascalr;

  .#? I matrix.pascal\n  generate an I by I matrix representation of pascal's triangle
  {n::num, [1nL{_matrix.nextpascalr}nV%] matrix!}:pascal;

  .#? IIN matrix.newfill\n  create a I1 by I2 matrix filled with N3
  {\L\Lmatrix!}:newfill;

  .#? N (matrix) matrix.fill\n  fill matrix with N everywhere
  {n::num m, n m.cL m.rLmatrix!}:fill;

  .#? NN matrix.zeros\n  create a N1 by N2 matrix of zeros
  {0matrix.newfill}:zeros;

  .#? NN matrix.ones\n  create a N1 by N2 matrix of ones
  {1matrix.newfill}:ones;

  .#? NN matrix.rand\n  create a N1 by N2 matrix of random values [0,1]
  {0matrix.newfill {;.Q} matrix.map}:rand;

  .#? NNN matrix.randint\n  create a N2 by N3 matrix of random integers from 1 to N1
  {:n,@:n; 0matrix.newfill {;nQ} matrix.map}:randint;

  .#? (matrix) E matrix.map\n  map an expression to each element of the matrix
  {mat expr::block, mat.rows : {#expr} mat.:rows; mat}:map;

  .#? N matrix.multiptable\n  generate n N by N multiplication table
  {[1|_R_@L\,#*] matrix!}:multiptable;

}:matrix;

matrix:m;
