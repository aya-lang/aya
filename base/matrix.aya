.# This file is a part of Aya: https://github.com/nick-paul/aya-lang

.# matrix.aya
.# Defines the matrix type

import ::str
import ::list
import ::math

.{? type: matrix
    Matrix manipulations and representations
.}

{,

  ::matrix :type;

  .#? L<L> matrix.is\n  returns true if the list contains lists that are the same length and only contain numbers
  {m,
  .# Both of the following must be true:
    m#:T{::list=}all .# The list is made up of only other lists
    {
        m#E{m0IE=}all           .# All of the list lengths are the same
    } 0 .?
  }:is;

  .# matrix constructor: first test if it is a valid matrix
  {in::list,
    in matrix.is
    {{,in:rows} matrix MO}
    {in P " is not a valid matrix" K .D}
    .?
  }:new;

  .#? ::matrix matrix.dim\n  return the dimention of the matrix\n  [#rows #cols]
  {.rows.E\0IEK}:dim;

  .#? ::matrix matrix.issq\n  returns true if the list is a square matrix
  {m, m.rowsE m.rows#E\#= {|}F}:issq;

  .#? ::matrix matrix.tr\n  trace of a matrix as a list
  {m, [m.rows_ER,VI]}:tr;

  .#? ::matrix matrix.t\n  transpose a matrix
  {m, m.rows .T matrix!}:t;



  .# Elementary row operations

  .#? NN::matrix rowmul\n  multiply row N2 by a scalar N1
  {n rn mat,
    mat.rows.[rn] n *  .# Multuply the rnth row by N
    mat.rows.:[rn]     .# and assign the rnth row of mat
    mat
  }:rowmul;

  .#? NN ::matrix matrix.rowswap\n swap rows N1 and N2 of the matrix
  {ra rb mat : tmp matrows,
    mat.rows :matrows;
    matrows.[ra] :tmp;            .# Store row N1 in a tmp var
      matrows.[rb] matrows.:[ra]   .# row N1 = row N2
      tmp matrows.:[rb]             .# row N2 = tmp
      mat
  }:rowswap;


  .#? NNN ::matrix matrix.rowadd\n  add a N1*(N2nd row) to the N3rd row
  {add ra rb mat : tmp matrows,
    mat.rows :matrows;
    matrows.[ra] add #*:tmp;              .# Multiply the N2 row by N1
      [matrows.[rb] tmp, +] matrows.:[rb]    .# Add the N2 row to N3
    mat
  }:rowadd;



  .############
  .# INDEXING #
  .############

  .#? NII ::matrix matrix.set\n  set the item at index I1, I2 to N
  {n::num i::num j::num m,
    n m.rows.[i].:[j]
    m
  }:set;

   .#? ::matrix matrix.r\n  return the number of rows in the matrix
  {.rowsE}:r;

  .#? ::matrix matrix.r\n  return the number of cols in the matrix
  {.rows0IE}:c;

  .#? ::matrix matrix.cols\n  return the columns as a list of lists
  {.rows .T}:cols;


  .{? ::matrix [row col] matrix.getindex\n  return the element at (r,c)
  r and c may be lists
  if r is [], use all rows
  if c is [], use all cols .}
  {ix mat : r c,
    ix0I :r;
    ix1I :c;

    .# Get the data
    mat.rows r I
    r :T ::num = {A} ?
    #{cI}

    .# Transform the data based on input type
    .# Return a new matrix if possible
    c :T ::num = {
      r :T ::num = {
        .# `r` and `c` both nums, return a single item
        0I
      } {
        .# Only columns returned, wrap each in a list
        #A matrix!
      } .?
    } {
      .# Only rows returned, convert to matrix
      matrix!
    } .?
  }:getindex;



  .########################
  .# ARITHMETIC OVERLOADS #
  .########################

  .#? N ::matrix (\) matrix.add\n  add a number or another matrix
  {o self,
    o:T ::matrix = {
      [o.rows self.rows, +] matrix!
    } {
      self.rows # {o+} matrix!
    }.?
  }:add;

  {self o,
    self.rows # {o+} matrix!
  }:radd;


  .#? N ::matrix (\) matrix.sub\n  subtract a number or another matrix
  {o self,
    o:T ::matrix = {
      [o.rows self.rows, \-] matrix!
    } {
      self.rows # {o\-} matrix!
    }.?
  }:sub;

  {self o,
    self.rows # {o-} matrix!
  }:rsub;


  .#? ::matrix N (\) matrix.div\n  divide matrix by a number
  {o self,
    self.rows # {o\/} matrix!
  }:div;

  {self o,
    self.rows # {o/} matrix!
  }:rdiv;


  .#? N ::matrix (\) matrix.mul\n  multiply a number or another matrix
  {o self,
    o:T ::matrix = {
      o self.matmul
    } {
      self.rows # {o\*} matrix!
    }.?
  }:mul;

  {o self,
    o.c self.r =! {"matrix.mul: dim mismatch $(o.c) != $(self.r)".D} ?
    .# (*S) is the dot product
    o.rows  # {r, self.t.rows#{r *S}}
    matrix!
  }:matmul;

  {self o,
      self.rows # {o*} matrix!
  }:rmul;



  .#? ::matrix N matrix.rpow\n  raise matrix to the Nth power
  {mat exp::num,
    "matrix.pow: exponent must be positive" exp 1 < conderr
    mat {_} exp V %
    {.matmul} exp V %
  }:rpow;

  .#############
  .# ITERATION #
  .#############


  .#? ::block ::matrix matrix.apply\n  apply an expression to each element of the matrix in place
  {expr::block mat::matrix,
    mat.rows # {#expr} mat.:rows; mat
  }:apply;

  .#? ::block ::matrix matrix.map\n  make a copy of the matrix and apply an expression to each element
  {expr::block mat::matrix,
    mat.rows #{#expr} matrix!
  }:map;

  .#? ::block ::matrix matrix.each\n  apply an expression to each element of a matrix, return nothing
  {expr::block mat::matrix,
    mat.rows #{#expr};
  }:each;




  .###################
  .# OTHER OVERLOADS #
  .###################

  .# Math overloads
  [aya.mathoverload _ :K\:V, {k v,
    "{.rows #{# $v } matrix!} :$(k:C);" .~
  }] #~


  .#? ::matrix ::matrix matrix.eq\n  test if two matrices are equal
  {a b,
     a.dim b.dim =! 0 {[a.rows b.rows,=]{&}F} .?
  }:eq;

  .#? ::matrix matrix.signnum\n  apply signnum to each element of the matrix
  {.rows #{#.!} matrix!}:signum;

  .#? ::matrix matrix.repr\n  converts a matrix to a string
  {
    .rows matstr
    "\n"" |\n|"@.&       .# Inside bars
    " |"K'|\K            .# Outside bars
    "\n"+ "\n"\+
  }:repr;

  .#######################
  .# GENERATOR FUNCTIONS #
  .#######################

  .#? N matrix.i\n  generate an Nd identity matrix
  {
    _0\L1\K\_KL {,}.:rows matrix MO
  }:eye;

  .# generates the next row of a pascal matrix
  {prev::list : new len ix,
    prevE:len;
    1 0 lenVLK:new;
    1:ix;
    {prev ixI new ixVI+ new.:[ix] ::ix B}lenV%
    new
  }:nextpascalr;

  .#? I matrix.pascal\n  generate an I by I matrix representation of pascal's triangle
  {n::num, [1nL{_matrix.nextpascalr}nV%] matrix!}:pascal;

  .#? IIN matrix.newfill\n  create a I1 by I2 matrix filled with N3
  {\L\Lmatrix!}:newfill;

  .#? N ::matrix matrix.fill\n  fill matrix with N everywhere
  {n::num m, n m.cL m.rLmatrix!}:fill;

  .#? NN matrix.zeros\n  create a N1 by N2 matrix of zeros
  {0 matrix.newfill}:zeros;

  .#? NN matrix.ones\n  create a N1 by N2 matrix of ones
  {1 matrix.newfill}:ones;

  .#? NN matrix.random\n  create a N1 by N2 matrix of random values [0,1]
  {K0\L #{#{;.Q}} matrix!}:random;

  .#? NNN matrix.randint\n  create a N2 by N3 matrix of random integers from 1 to N1
  {@@K L #{#Q} matrix!}:randint;

  .#? N matrix.multiptable\n  generate n N by N multiplication table
  {[1|_R_@L\,#*] matrix!}:multiptable;

  .##################
  .# INPUT / OUTPUT #
  .##################

  .#? S matrix.fopen\n  open a space-delimited file containing a matrix as a matrix object
  {G"\n"|#{" "|#~}matrix!}:fopen;

  .###################
  .# TRANSFORMATIONS #
  .###################

  .# [::matrix] matrix.vstack\n  stack a list of matrices vertically
  {
    #{.rows~}matrix!
  }:vstack;

  .# [::matrix] matrix.hstack\n  concat a list of matrices horizontally
  {
    [1|#.rows~,.A.F] matrix!
  }:hstack;



}:matrix;

matrix:m;



.#########
.# TESTS #
.#########

import ::test

`~ {:ts,

  "matrix" testset! :ts;

  {[[1 2][3 4]] m! :T} [::matrix] ts+
  {[[1 2][3 4]] m.is} [1] ts+
  {[[1][3 4]] m.is} [0] ts+
  {[[1][2][3]] m! .dim} [[3 1]] ts+
  {[[1 2 3]] m! .dim} [[1 3]] ts+
  {[[1 2][3 4]]m! .issq} [1] ts+
  {[[1 2]]m! .issq} [0] ts+
  {[[1 2][3 4]]m! .tr} [[1 4]] ts+
  {[[1 2][3 4]]m! .t .rows} [ [[1 3][2 4]] ] ts+
  {2 0 [[1 1][2 2]]m! .rowmul .rows} [ [[2 2][2 2]] ] ts+
  {0 2 [[1 1][2 2][3 3]]m! .rowswap .rows} [ [[3 3][2 2][1 1]] ] ts+
  {3 0 1 [[1 1][2 2]]m! .rowadd .rows} [ [[1 1][5 5]] ] ts+
  {10 0 0 [[1 2][3 4]]m! .set .rows} [ [[10 2][3 4]] ] ts+
  {[[1 2][3 4][5 6]]m! .r} [3] ts+
  {[[1 2][3 4][5 6]]m! .c} [2] ts+
  {[[1 2][3 4][5 6]]m! .cols} [ [[1 3 5][2 4 6]] ] ts+

  .# Indexing
  {3 m.pascal .rows} [ [[1 1 1][1 2 3][1 3 6]] ] ts+
  {3 m.pascal.[2 2]} [6] ts+
  {3 m.pascal [[] 2] I .rows} [ [[1][3][6]] ] ts+
  {3 m.pascal [2 []] I .rows} [ [[1 3 6]] ] ts+
  {3 m.pascal [[] []] I .rows} [ [[1 1 1][1 2 3][1 3 6]] ] ts+
  {3 m.pascal [0 [0 1]] I .rows} [ [[1 1]] ] ts+
  {3 m.pascal [[0 1] 0] I .rows} [ [[1][1]] ] ts+
  {3 m.pascal [[0 1] []] I .rows} [ [[1 1 1][1 2 3]] ] ts+
  {3 m.pascal [[] [0 1]] I .rows} [ [[1 1][1 2][1 3]] ] ts+
  {3 m.pascal [[0 1][0 1]] I .rows} [ [[1 1][1 2]] ] ts+

  .# Arithmetic
  {[[1 2][3 4]]m! _ + .rows} [ [[2 4][6 8]] ] ts+
  {[[1 2][3 4]]m! 10 + .rows} [ [[11 12][13 14]] ] ts+
  {10 [[1 2][3 4]]m! + .rows} [ [[11 12][13 14]] ] ts+
  {[[1 2][3 4]]m! _ - .rows} [ [[0 0][0 0]] ] ts+
  {[[1 2][3 4]]m! 10 - .rows} [ [[:9 :8][:7 :6]] ] ts+
  {10 [[1 2][3 4]]m! - .rows} [ [[9 8][7 6]] ] ts+
  {[[1 2][3 4]]m! _ * .rows} [ [[7 10][15 22]] ] ts+
  {[[1 2][3 4]]m! 10 * .rows} [ [[10 20][30 40]] ] ts+
  {10 [[1 2][3 4]]m! * .rows} [ [[10 20][30 40]] ] ts+
  {[[1 2][3 4]]m! 10 / .rows} [ [[.1 .2][.3 .4]] ] ts+
  {12 [[1 2][3 4]]m! / .rows} [ [[12 6][4 3]] ] ts+
  {[[1 2][3 4]]m! 2 ^ .rows} [ [[7 10][15 22]] ] ts+

  .# Iteration
  {:a, [[1 2][3 4]]m!:a; {2*} a.apply.rows} [ [[2 4][6 8]] ] ts+
  {:a, [[1 2][3 4]]m!:a; {2*} a.apply; a.rows} [ [[2 4][6 8]] ] ts+
  {:a, [[1 2][3 4]]m!:a; {2*} a.map.rows} [ [[2 4][6 8]] ] ts+
  {:a, [[1 2][3 4]]m!:a; {2*} a.map; a.rows} [ [[1 2][3 4]] ] ts+
  {:a, [[1 2][3 4]]m!:a; {2*} a.each a.rows} [ [[1 2][3 4]] ] ts+

  .# Other Overloads
  .# No need to check them all, just check to see if they are loaded
  {[[1 2][3 4]] m! M! .rows} [ [[1 2][6 24]] ] ts+
  {[[1 2][3 4]] m! _ =} [1] ts+
  {[[1 2][3 4]] m! 2 m.pascal =} [0] ts+
  {[[:4 5][6 0]] m! .! .rows} [ [[:1 1][1 0]] ] ts+

  .# Generators
  {3 m.eye.rows} [ [[1 0 0][0 1 0][0 0 1]] ] ts+
  {3 m.pascal.rows} [ [[1 1 1][1 2 3][1 3 6]] ] ts+
  {2 2 10 m.newfill.rows} [ [[10 10][10 10]] ] ts+
  {10 [[1 1][3 3]]m! .fill.rows} [ [[10 10][10 10]] ] ts+
  {3 2 m.zeros.rows} [ [[0 0][0 0][0 0]] ] ts+
  {2 3 m.ones.rows} [ [[1 1 1][1 1 1]] ] ts+
  {3 m.multiptable.rows} [ [[1 2 3][2 4 6][3 6 9]] ] ts+

  .# Transformations
  {[2 m.eye _] m.hstack.rows} [ [[1 0 1 0][0 1 0 1]] ] ts+
  {[2 m.eye _] m.vstack.rows} [ [[1 0][0 1][1 0][0 1]] ] ts+



  ts aya.addtest
}
