import "string"
import "list"
import "types"
import "math"

.{? type: matrix
    Matrix manipulations and representations
.}

{,

  ::matrix :type;

  .#? L<L> matrix.is\n  returns true if the list contains lists that are the same length and only contain numbers
  {m,
  .# Both of the following must be true:
  	m#:T{::list=}all .# The list is made up of only other lists
  	{
  		m#E{m0IE=}all 			.# All of the list lengths are the same
  	} 0 .?
  }:is;

  .# matrix constructor: first test if it is a valid matrix
  {in::list,
    in matrix.is
    {{,in:rows} matrix MO}
    {in P " is not a valid matrix" K .D}
    .?
  }:new;

  {.rows.E\0IEK}:dim; .#? (matrix) matrix.dim\n  return the dimention of the matrix\n  [#rows #cols]
  {m, m.rowsE m.rows#E\#= {|}F}:issq;          .#? (matrix) matrix.issq\n  returns true if the list is a square matrix
  {m, [m.rows_ER,VI]}:tr;                       .#? (matrix) matrix.tr\n  trace of a matrix as a list
  {m, m.rows .T matrix!}:t;          .#? (matrix) matrix.t\n  transpose a matrix
  {*S}:dot;                                .# dot product of two lists





  .# Elementary row operations

  .#? NN(matrix) rowmul\n  multiply row N2 by a scalar N1
  {n rn mat,
    (mat.rows rn :           .# Assign the rnth row of mat...
	  (mat.rows rn I #{n*})  .# ..to the rnth row times n
	  );
    mat
  }:rowmul;

  .# NN(matrix) rowswap\n swap rows N1 and N2 of the matrix
  {ra rb mat : tmp matrows,
    mat.rows :matrows;
    matrows ra I :tmp;            .# Store row N1 in a tmp var
	(matrows ra:(matrows rb I));  .# row N1 = row N2
	(matrows rb:(tmp));           .# row N2 = tmp
	mat
  }:rowswap;


  .# NNN (matrix) rowadd\n  add a N1*(N2nd row) to the N3rd row
  {add ra rb mat : tmp matrows,
    mat.rows :matrows;
    matrows ra I add #*:tmp;              .# Multiply the N2 row by N1
	 (matrows rb:([matrows rb I tmp, +])); .# Add the N2 row to N3
	mat
  }:rowadd;

  .# Augment
  {mata matb,
    "matrix.augment: both must have same number of rows" mata.r matb.r =! conderr
    [mata.rows matb.rows,K]matrix!
  }:augment;


  .# from rref
  .# invert
  .# rank
  .# det

  .# Indexing
  {n::num i::num j::num m, (m.rows iI j : (n));m}:set;      .#? NII (matrix) matrix.set\n  set the item at index I1, I2 to N
  {.rowsE}:r;                                   .#? (matrix) matrix.r\n  return the number of rows in the matrix
  {.rows0IE}:c;                                 .#? (matrix) matrix.r\n  return the number of cols in the matrix
  {.rows .T}:cols;                         .#? (matrix) matrix.cols\n  return the columns as a list of lists


  .{? (matrix) [row col] matrix.index\n  return the element at (r,c)
  if r is [], return the cth col
  if c is [], return the rth row .}
  {ix mat : r c out,
    ix0I:r;
    ix1I:c;

    .# all rows
    r [] = {
      .# all columns
      c [] = {
       .# all rows, all cols: return entire mat
       mat.rows
      } {
        .# return col(s) c
        mat.cols c I .T
      } .?
    } { .# specific rows
      .# all columns
      c [] = {
        .# col empty, return entire row
        mat.rows r I
      } {
        .# specific rows and columns
        mat.rows r I

        .# if r is a list, take c from each row
        r :T ::list = {
          #{c I}
          c :T ::num = {A.T} ?
        } {
          c I
        } .?

      } .?
    } .?

    :out

    .# If out is a 1d list, wrap it before constructing the new matrix
    out :T ::list = {
      out 0 I :T ::list =! {A} ?
      matrix!
    } ?

  }:index;


  .########################
  .# ARITHMETIC OVERLOADS #
  .########################


  {o self,
    o:T ::matrix = {
      [o.rows self.rows, +] matrix!
    } {
      self.rows # {o+} matrix!
    }.?
  }:add;

  {self o,
    self.rows # {o+} matrix!
  }:radd;



  {o self,
    o:T ::matrix = {
      [o.rows self.rows, \-] matrix!
    } {
      self.rows # {o\-} matrix!
    }.?
  }:sub;

  {self o,
    self.rows # {o-} matrix!
  }:rsub;



  {o self,
    o:T ::matrix = {
      [o.rows self.rows, \/] matrix!
    } {
      self.rows # {o\/} matrix!
    }.?
  }:div;

  {self o,
      self.rows # {o/} matrix!
  }:rdiv;



  {o self,
    o:T ::matrix = {
      o self.matmul
    } {
      self.rows # {o\*} matrix!
    }.?
  }:mul;

  {o self,
    o.c self.r =! {"matrix.mul: dim mismatch ($o.c) != $(self.r)".D} ?
    .# (*S) is the dot product
    o.rows  # {r, self.t.rows#{r *S}}
    matrix!
  }:matmul;

  {self o,
      self.rows # {o*} matrix!
  }:rmul;



  .#? N (matrix) matrix.pow\n  raise matrix to the Nth power
  {mat exp::num,
    "matrix.pow: exponent must be positive" exp 1 < conderr
    mat {_} exp V %
    {.matmul} exp V %
  }:rpow;

  .#############
  .# ITERATION #
  .#############

  .#? (matrix) E matrix.map\n  map an expression to each element of the matrix
  {mat expr::block, mat.rows : {#expr} mat.:rows; mat}:map;



  .###################
  .# OTHER OVERLOADS #
  .###################

  .# Math overloads
  [aya.mathoverload _ :K\:V, {k v,
    "{.rows #{# $v } matrix!} :$k;" .~
  }] #~


  .#? (matrix) (matrix) matrix.eq\n  test if two matrices are equal
  {a b,
     a.dim b.dim =! 0 {[a.rows b.rows,=]{&}F} .?
  }:eq;

  {.rows #{#.!} matrix!}:signum;

  .#? (matrix) matrix.show\n  converts a matrix to a string
  {
    .rows matstr
    "\n"" |\n|"@.&       .# Inside bars
    " |"K'|\K            .# Outside bars
    "\n"+
  }:repr;

  .#######################
  .# GENERATOR FUNCTIONS #
  .#######################

  .#? N matrix.i\n  generate an Nd identity matrix
  {
    _0\L1\K\_KL {,}.:rows matrix MO
  }:eye;

  .# generates the next row of a pascal matrix
  {prev::list : new len ix,
    prevE:len;
    1 0 lenVLK:new;
    1:ix;
    new {(ix:(prev ixI new ixVI+)) ixB:ix;}lenV%
  }:nextpascalr;

  .#? I matrix.pascal\n  generate an I by I matrix representation of pascal's triangle
  {n::num, [1nL{_matrix.nextpascalr}nV%] matrix!}:pascal;

  .#? IIN matrix.newfill\n  create a I1 by I2 matrix filled with N3
  {\L\Lmatrix!}:newfill;

  .#? N (matrix) matrix.fill\n  fill matrix with N everywhere
  {n::num m, n m.cL m.rLmatrix!}:fill;

  .#? NN matrix.zeros\n  create a N1 by N2 matrix of zeros
  {0matrix.newfill}:zeros;

  .#? NN matrix.ones\n  create a N1 by N2 matrix of ones
  {1matrix.newfill}:ones;

  .#? NN matrix.rand\n  create a N1 by N2 matrix of random values [0,1]
  {K0\L #{#{;.Q}} matrix!}:rand;

  .#? NNN matrix.randint\n  create a N2 by N3 matrix of random integers from 1 to N1
  {@@K L #{#Q} matrix!}:randint;

  .#? N matrix.multiptable\n  generate n N by N multiplication table
  {[1|_R_@L\,#*] matrix!}:multiptable;

  .##################
  .# INPUT / OUTPUT #
  .##################

  .#? S matrix.fopen\n  open a space-delimited file containing a matrix as a matrix object
  {G"\n"|#{" "|#~}matrix!}:fopen;

  .###################
  .# TRANSFORMATIONS #
  .###################

  .# [::matrix] matrix.vstack\n  stack a list of matrices vertically
  {
    #{.rows~}matrix!
  }:vstack;

  .# [::matrix] matrix.hstack\n  concat a list of matrices horizontally
  {
    [1|#.rows~,.A.F] matrix!
  }:hstack;



}:matrix;

matrix:m;
