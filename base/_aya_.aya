.# _aya_
.# Defines the aya namespace and Aya keywords

.# NOTE: 12 letter variables ending in the letter 'z' are reserved for use in
.#       standard library. Such variables are used below.



{, .# begin aya namespace

[
  "_aya_"  .# This file
]:imported;

""2MZ "base/" K :basedir;
""2MZ :homedir;


{importnamezz importdirnmz,

  .# True if the fine is not imported
  aya.imported importnamezz N\; :-1 =

  .# If condition is true
  { .# File not already imported, load it

    .# Add the name to the list
    importnamezz aya.imported .B;

    { .# try
      .# Load the file
      importdirnmz importnamezz + ".aya" + G ~
    } { .# catch
      .# Remove the file from imported list
      aya.imported importnamezz N .- ;
      "Error importing " importnamezz + .D
    } .K

  }

  .# If condition is false
  { .# File already imported
    .# do nothing
  }
  .?

}:importfrmdir;


.# importbase uses the home dir instead of the
.# base dir
{
  aya.basedir aya.importfrmdir
}:importbase;


.# importfile uses the home dir instead of the
.# base dir
{
  aya.homedir aya.importfrmdir
}:importfile;

{importnamezz,
  .# Does the name contain a file sep? (9M|)
  .# 9M| _ "\\"= {}{;"\\\\"} .? returns an escaped "\" -> "\\" if windows
  importnamezz _ (9M| _ "\\"= {;"\\\\"} {} .?) | S=

  { .# No file sep, import from base
    importnamezz aya.importbase
  }

  { .# input contains a file sep
    importnamezz aya.importfile
  }

  .?
}:import;


{
  [] aya.:imported;
}:resetimports;

}:aya;





.#######################
.# DEFINE AYA KEYWORDS #
.#######################



.# ------
.# IMPORT
.# ------

.#? import library\n  import a aya file\n  files are only imported once
{`(
    .# Split whitespace separated names
    "\W+" | [""] :| #{aya.import};
)}:import;




.# ------
.# RELOAD
.# ------

.#? reload\n  reload the standard library
{:workingdirzz,
  ""2MZ :workingdirzz;  .# Save the current working dir
  ""3MZ                 .# Reset the working dir
  aya.resetimports      .# Reset imports cache (just in case)
  "ayarc.aya" G ~       .# Load ayarc.aya
  workingdirzz 3 MZ     .# Change the working dir back
}:reload;




.# ----
.# LOAD
.# ----

.#? load S\n  Load a script
{`(".aya"+G~)}:load;



.# -----
.# USING
.# -----

.# using dict\n  import variables from a dict into the global scope
{`W}:using;






.###########
.# CONTROL #
.###########

.#? if (B) E E\n  if statement:\n  if (bool value) {\n    then\n  } {\n    else\n  }
{```.?}:if;


.#? B then E\n  evaluates E if B is true
{`?}:then;


.#? dowhile E E\n  evaluates E1 as long as E2 is true\n  always evaluates at least once
{``({dowhilecondz dowhileloopz, {dowhileloopz dowhilecondz}W})}:dowhile;


.#? while E E\n  evaluates E1 as long as E2 is true
{``({whilecondzzz whileloopzzz,
  whilecondzzz
  {{whileloopzzz whilecondzzz}W}
  {}
  .?
})}:while;


.#? for S|C L E\n  for loop\n  for "varname" [list] {\n    expressions\n  }
{```({forloopczzzz forlooplistz forloopblkzz,
  "forlooplistz#{:$forloopczzzz; forloopblkzz}"~
})}:for;


.#? A print\n  convert to string a print to console
{.P}:print;


.#? A println\n  convert to string and print to console on its own line
{:P}:println;

.#? getline\n  read input from stdin and return it as a string
{:R}:getline;


.#? try EE\n  evaluate the first block, if error, then evaluate the second block
{``.K}:try;


.#? SB conderr\n  throw error message if condition is true
{{.D} {;} .?}:conderr;


.#? E assert L\n  Evaluates E as a list, throws an error if [E~] != L
{`({blkE expectedL,
  if ([blk] expected=) {
	  .# Do nothing
	} {
    .# Throw an error message about the assertation
	  ["assert " "blk".Z " = " expectedP  "\n\trecieved: " [blk]P]SP.D
	}
})}:assert;
