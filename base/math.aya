.# math.aya
.# Essential math functions for Aya

import "types"
import "list"

.# Constants

1M|:euler; .#? euler\n  euler's constant e
0M|:pi;    .#? pi\n  constant \{pi}
4M|:nan;   .#? nan\n  not a number double literal
5M|:inf;   .#? inf\n  infinity double literal
6M|:minf;  .#? minf\n  minus infinity double literal

.# sqrt(2)
2ZMq:sqrttwo;

.# sqrt(3)
3ZMq:sqrtthree;



.#? phi: golden ratio (constant)
.# Compute phi using 2 adjacent fib numbers
[1000 _B, 1\0{_@+}@%;]_1I\0I/
:phi;

1 4/:fourth;	.# ¼
1 2/:half;		.# ½



.# Essential Functions

{MA}:abs;						.#? N abs\n  absolute value
{_E\S\/}:avg;				.#? L avg\n  average of a list of numbers
{1 3/^}:cbrt;    		.#? N cbrt\n  cube root
{./}:ceil;      		.#? N ceil\n  ceiling
{pi*180/}:deg;    	.#? N deg\n  convert deg to rad (180° => 3.14..)
{180*pi/}:rad;      .#? N rad\n  convert rad to deg (pi rad => 180)
{euler\^}:exp;    	.#? N exp\n  exp(x)
{M!}:fact;      		.#? N fact\n  factorial
{.\}:floor;      		.#? N floor\n  floor
{_.\-}:frac;    		.#? N frac\n  fractional part
{1-M!}:gamma;				.#? N gamma\n  gamma function
{2^\2^+Mq}:hypot;   .#? N hypot\n  hypotenuse function
{G}:isprime;        .#? N isprime \n  tests a number for primality
{ML2ML/}:lg;				.#? N lg\n  base-2 log
{Ml}:ln;      			.#? N ln\n  natural log
{ML}:log;      			.#? N log\n  base-10 log
{ML\ML\/}:logn;			.#? N logn\n  base-n log\n ex: log base 6 of 10 written as (10 6logn)
{1-M!MAMl}:lngamma;	.#? N lngamma\n  ln(abs(gamma(x)))
{%}:mod;            .#? N mod\n  modulo
{_#2^SMq#/}:normal; .#? L<N> normal\n  compute the normal vector of the given list
{Mp}:primes;        .#? N primes\n  returns a list containing the primes up to and including N
{{*}U}:product;     .#? L product\n  product of a list
{.!}:signnum;       .#? N signnum \n  returns the sign of a number (1,0,-1)
{Mq}:sqrt;          .#? N sqrt\n  square root
{M$3E.\}:ts;      .#? ts\n  return the system time in seconds as an int
{.%}:div;					.#? <NN> div\n  integer division
{%}:rem;						.#? <NN> rem\n  remainder after division
{PE}:numofdigits;   .#? N numofdignts\n  number of digits in N

.# Additional Math Functions

.#? NN lcm\n least common multiple of two numbers or a list of numbers
{_'Nisa {.-}{{.-}U} .?}:lcm;

.#? NN gcd \n  greatest common divisior of 2 numbers or a list of numbers
{_ 'Nisa {.+}{{.+}U} .?}:gcd;


.#? N factors \n  returns a list of the numbers factors
{n, [1 n,, n\%0=]}:divisors;

.#? L geomean \n  geometric mean
.# the nth root of the product of n numbers
{_E\{*}U1@/^}:geomean;

.#? L median \n  median value of a list
{l,
  l$_E2/.\               .# Sort the list and get its middle index
  lE2%0= {_1-KIS2/} {I}  .?  .# If the list has even length, average the middle two
                          .# The list has odd length, take the middle item
}:median;

.#? L<N> cumsum\n  cumulative summation of a list
{list : sum outlist,
  .# Allocate output list
  0 listE L :outlist;

  for 'i (list irange) {
    list iI sum + : sum;
    sum outlist i D
  };

  outlist
}:cumsum;

.#? L<N> cumprod\n  cumulative product of a list
{list : prod outlist,
  .# Initialize prod
  1:prod;

  .# Allocate output list
  0 listE L :outlist;

  for 'i (list irange) {
    list iI prod * : prod;
    prod outlist i D
  };

  outlist
}:cumprod;

.#? LL pearson\n  pearson correlation coefficient between 2 datasets
{x y : n xs ys,
  xE:n;
  xS:xs;
  yS:ys;

  [x y,*]Sn* xs ys*-
   x2^Sn* xs2^ -
   y2^Sn* ys2^ -
   * Mq
  /
}:pearson;

.#? N factors\n  compute a number's prime factors
.# golf: {n,{2to(nV){n\%0=}.NI_n\/fK}{n}nGn2<|?}:f;
{n,
  .# is the number prime
  nG n2< |

  .# If the number is prime, return it
  {n}

  .# If the number is not prime, find the
  .#   next factor
  {
    .# Range from 2..ceil(sqrt(n))
    [2nVMq./]R

    .# Find the next factor
    {n\%0=}.N

    .# Append this factor to the list of
    .#   factors recursively
    I _n\/ factors K
  }

  .?
}:factors;


.# Trigonometry

{Ms}:sin;                   .#? N sin \n  sine
{Mc}:cos;                   .#? N cos \n  cosine
{Mt}:tan;       			      .#? N tan \n  tangent
{Ms1\/}:csc;                .#? N csc \n  cosecant
{Mc1\/}:sec;                .#? N sec \n  secant
{Mt1\/}:cot;                .#? N cot \n  cotangent

{MS}:asin;                  .#? N asin \n  inverse sine
{MC}:acos;                  .#? N acos \n  inverse cosine
{MT}:atan;                  .#? N atan \n  inverse tangent
{1\/MS}:acsc;               .#? N acsc \n  inverse cosecant
{1\/MC}:asec;               .#? N asec \n  inverse secant
{1\/MT}:acot;               .#? N acot \n  inverse cotangent

{_exp\Texp-2/}:sinh;        .#? N sinh \n  hyperbolic sine
{_exp\Texp+2/}:cosh;        .#? N cosh \n  hyperbolic cosine
{_sinh\cosh/}:tanh;         .#? N tanh \n  hyperbolic tangent
{sinh1\/}:csch;             .#? N csch \n  hyperbolic cosecant
{cosh1\/}:sech;             .#? N sech \n  hyperbolic secant
{tanh1\/}:coth;             .#? N coth \n  hyperbolic cotangent

{_2^1+Mq+Ml}:asinh;             .#? N asinh \n  inverse hyperbolic sine
{__1-Mq\1+Mq*+Ml}:acosh;        .#? N acosh \n  inverse hyperbolic cosine
{_1\+Ml\1\-Ml-0.5*}:atanh;      .#? N atanh \n  inverse hyperbolic tangent
{_1\/\2^1\/1+Mq+Ml}:acsch;      .#? N acsch \n  inverse hyperbolic cosecant
{1\/__1+Mq\1-Mq*+Ml}:asech;    	.#? N asech \n  inverse hyperbolic secant
{1\/_1\-Ml\1+Ml\-0.5*}:acoth;  	.#? N acoth \n  inverse hyperbolic cotangent


.# Combinatorics

{`({n r, nM! n r-M!/})}:npr;        .# Permutations (nPr) (infix operator)
{`({n r, nM! n r- M!/ rM!/})}:ncr;  .# Combinations (nCr) (infix operator)

.# Bits
{2 10 H}:unbit;   .#? L unbit \n  convert a list of bits to a number
{10 2 H}:bits;    .#? N bits \n  convert a positive number to a list of bits
{10 16 H}:hex;    .#? N hex\n  convert an int into a hex string
{16 10 H}:unhex;  .#? S unhex\n  convert a hex string to an int




.# Statistics
{set : m, set avg:m; set#{m-2^}S setE /}:variance;
{variance Mq}:stdev;

.#? xL xL regression\n  return a block that evaluates to the regression of the sets
{x y :
  n a b
  sumy sumx
  sumxsq
  sumxytimes,

  xE:n;
  x2#^S:sumxsq;
  [x y,*]S:sumxytimes;
  xS:sumx;
  yS:sumy;


  sumy sumxsq *  sumx sumxytimes * -
  n sumxsq * sumx2^ -
  /:a;

  n sumxytimes * sumx sumy * -
  n sumxsq * sumx2^-
  /:b;

  "{($b)*($a)+}"~
}:regression;


.# Vector
{[2|,*]S}:bullet:dot; .#? dot\n dot (scalar) product of two lists
