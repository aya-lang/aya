.# list.aya
.# Defines functions for working with lists

.# Basic functions

{\N\;(-1)=!}:in;       .#? AL in\n  tests whether or not item `a` is in list `l`
{N\;(-1)=!}:ni;        .#? LA ni\n  tests whether or not item `a` is in list `l`
{AKR}:range;           .#? NN range\n  generates a range from n1 to n2
{R#{;.Q}}:randset;     .#? I randset\n  generate a set of random nums (0 to 1) of length i
{B\.V}:roll;           .#? L roll\n  move the last element to the front
{_@K\K}:surround;      .#? LA surround\n  append A to the front and back of L
{p q e, [p q, e]}:zw;  .#? LLE zw\n  zip with
{{.<}F}:max;           .#? L max\n  max value of a list
{{.>}F}:min;           .#? L min\n  min value of a list




.# Testing / Conditions

{{&}F}:allt;     .#? <L> allt\n  true if all elements in list are true
{{|}F!}:allf;    .#? <L> allf\n  true if all elements in list are false
{\_@IE\E=}:all;  .#? <LE> all\n  tests if all elements of the list meet the condition
{IE0>}:any;      .#? <LE> any\n  returns true of any elements satisfy the predicate




.# Other Functions

.#? L enumerate\n  return a list of index-value pairs for the list
{.E.R{A.B}zw}:enumerate;

.#? L rank\n  rank a list
{_{>}pu#S1+}:rank;

.#? AEN rpt\n  start at A and repeat E N times on the previous value of the list
{start expr len,
  [start {_ expr} len %]
}:rpt;

.#? N digits\n  convert a number into a list of digits
.# '0 = 48
{P"\."|V\;#:'48-}:digits;

.#? LI lotto\n  pick N random items from L
{\.EV@L#QI}:lotto;

.#? L irange\n generates a range of indices for the list
{E.R}:irange;

.#? <LLE> pu\n  (permusing) permutes elements of two lists and applies an expression to each
{la lb ex, [la lb laEL,\#{ex}]}:pu;

.#? <LII> swap\n  swap two elements in a list given their indices
{list::list i::num j::num : tmp,
  list i I : tmp;
  list j I  list i D;
  tmp list j D
}:swap;

.#? <L> shuffle\n  shuffle a list
{{;.Q}.$}:shuffle;

.#? NNN linspace\n  create a uniform range from n1 to n2 with n3 steps\n  (also see intspace)
{a b nums,
  a b=
  a numsL .# a=b, return nums a's
  {[a b a-numsV/a+ b,]}
  .?

  .# If the length is not equal to nums, add b to the end
  _Enums={}{bK}.?
}:linspace;

.#? III intspace\n create a range from a to b consisting of c ints\n  (also see linspace)
{a b l, [a b l linspace,.\]}:intspace;

.#? L<N> digitstonum\n  convert a list of numbers into a number
{l::list : total multip,
  1:multip;
  lU#{
    multip* total+:total;
    multip 10 *:multip
  };
  total
}:digitstonum;

.#? list makesquare\n  make all lists in the given 2d lists the same length
{list,
  list_ #E {.<}F
  #.<
}:makesquare;

.#? list expr tw\n  (takewhile) take from list while the condition is satisfied
{e,{e!}.N _0= {;;[]} {|;} .? }:tw;


.#########
.# TESTS #
.#########

import ::test

`~ {:ts,

  "list" testset! :ts;

  {4 [1 2 3] in} [0] ts+
  {[1 2 3] 4 ni} [0] ts+
  {2 [1 2 3] in} [1] ts+
  {[1 2 3] 2 ni} [1] ts+
  {4 8 range} [[4 5 6 7 8]] ts+
  {4 randset E4=} [1] ts+
  {[1 2 3 4] roll roll} [[3 4 1 2]] ts+
  {"abc" _\; '~ surround} ["~abc~"] ts+
  {[1 2] [3 4] {+} zw} [[4 6]] ts+
  {[1 2 3 4] max} [4] ts+
  {[1 2 3 4] min} [1] ts+

  {[1 1 1] allt} [1] ts+
  {[0 0 0] allt} [0] ts+
  {[1 0 1] allt} [0] ts+
  {[1 1 1] allf} [0] ts+
  {[0 0 0] allf} [1] ts+
  {[1 0 1] allf} [0] ts+
  {[1 2 3] {4<} all} [1] ts+
  {[1 2 3 4] {4<} all} [0] ts+
  {[1 2 3] {3=} any} [1] ts+
  {[7 8 9] {3=} any} [0] ts+
  {[] allt} [0] ts+
  {[] allf} [1] ts+
  {[] {3=} any} [0] ts+
  {[] {3=} all} [1] ts+

  {"abc" enumerate} [[[0 'a][1 'b][2 'c]]] ts+
  {[10] enumerate} [[[0 10]]] ts+
  {[4 7 3 2 7] rank} [[3 1 4 5 1]] ts+
  {[4] rank} [[1]] ts+
  {1 {2*} 4 rpt} [[1 2 4 8 16]] ts+
  {123 digits} [[1 2 3]] ts+
  {12.5 digits} [[1 2]] ts+
  {10R 4 lotto E 4 =} [1] ts+
  {"abc" irange} [[0 1 2]] ts+
  {"01""abc" {P+} pu .F} ["a0b0c0a1b1c1"] ts+
  {"abcd" _\; 0 :1 swap} ["dbca"] ts+
  {10R shuffle S} [55] ts+
  {0 1 5 linspace} [[0 .25 .5 .75 1]] ts+
  {1 10 4 intspace} [[1 4 7 10]] ts+
  {[2 4 2 5] digitstonum} [2425] ts+
  {[2] digitstonum} [2] ts+
  {[] digitstonum} [0] ts+
  {[[1 2][4][1 2 3]] makesquare} [[[1 2 0][4 0 0][1 2 3]]] ts+
  {[1 2 3 4 5] {4<} tw} [[1 2 3]] ts+
  {[1 2 3] {10=} tw} [[]] ts+

  ts aya.addtest

}
