.{? type: frac
    The frac type provides operations for manipulating fractions.

    Fractions can be created using the fraction literal operator `z` (eg: 1z2 =? 1/2) or by using the constructor manually.
.}

.#? module: frac\n  fraction conversions and manipulations
{@ frac,

  attr "n d"

  .{? N|S|L frac.new
    Fractions can be created using decimal approximations or lists.
    [4 7] frac.new => 4/7
    1.125 frac.new => 9/8
  .}
  {n,
    [
    .# Frac is already a frac
    n_ frac.instanceof.?

    .# Frac input is a list
    { "frac.new: must have two items" nE2=! conderr
      "frac.new: must contain only ints" n{'Nisa} all! conderr
      n#.] frac MO.reduce .# All tests passed
    } n 'L isa .?

    .# Frac input is a number
    {  n frac.approx
    } n 'N isa .?

    {"Cannot create fraction using $n".E}
    ].S
  }:new;

  .#? A frac.instanceof\n  returns true if A is an instance of a frac
  {Mw ".frac" =}:instanceof;

  .#? N frac.approx\n  approximate a decimal number as a fraction
  {_PE2-10\^_@\*\AK#{10*.]} frac MO .reduce}:approx;

  .#? (frac) frac.reduce\n  reduce a fraction as much as possible
  {f, [f.n f.d]_~gcd#{/.]} frac MO}:reduce;

  .#? (frac) frac.showelem\n  converts a fraction to a string of the form "N D/"
  {f, "$(f.n) $(f.d)/"}:showelem;

  .#? (frac) frac.show\n  converts a fraction to a string of the form "N/D"
  {f, "$(f.n)/$(f.d)"}:show;

  .#? (frac) frac.tofloat\n  converts a fraction to a decimal\n  overloaded operator: $
  {_.n\.d/}:tofloat;
  {_.n\.d/}:dollar;

  .#? (frac) frac.inv\n  multiplicative inverse
  {f, [f.d f.n] frac MO}:inv;

  .#? (frac) frac.negate\n  negate a fraction
  {f, [f.n! f.d] frac MO}:negate;

  .{? (frac)N frac.usedenom
  uses the input number as the new denominator for the fraction
  assumes the old denominator is a multiple of the new one
  ex: [1 3] 9 frac.usedenom => [3 9].}
  {denom self, denom [self.n self.d]_@\1I/#{*.]} frac MO}:usedenom;

  .#? (frac)(frac) frac.add\n  adds two fractions
  {a b,
    .# Convert a to a frac if needed
    a frac!:a;
    b frac!:b;

    .# Use lcm for denominators
    a.d b.d lcm_
    a.usedenom:a;
    b.usedenom:b;

    [a.n b.n+ a.d] frac MO .reduce
  }:plus;

  .#? (frac)(frac) frac.sub\n subtracts two fractions
  {frac!.negate.plus}:minus;

  .#? (frac)(frac) frac.mul\n  multiply two fractions
  {a b,
    .# Convert a to a frac if needed
    a frac!:a;
    b frac!:b;
    [a.n b.n*.] a.d b.d*.]] frac MO .reduce
  }:star:mul;

  .#? (frac)(frac) frac.fslash\n  divide two fractions
  {a b,
    .# Convert a to a frac if needed
    a frac!:a;
    b frac!:b;

    [a.n b.d*.] a.d b.n*.]] frac MO .reduce
  }:fslash;
  
  .#? (frac)(frac) frac.eq\n  tests if two fractions are equal
  {a b,
    a frac!:a;
    b frac!:b;
    a.n b.n = a.d b.d = &
  }:eq;

} .# END frac

.# Simple fraction literals
.# 1z2 => 1/2
{`(Kfrac.new)}:z;
