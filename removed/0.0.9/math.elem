.# math.elem
.# Essential math functions for element

.# NOTE: Most functions are not golfed. They
.# are written for performance, not length.

import "base/constants"

.# Essential Functions

{MA}:abs;						.#? N abs\n  absolute value
{_E\S\/}:avg;				.#? L avg\n  average of a list of numbers
{1 3/^}:cbrt;    		.#? N cbrt\n  cube root
{.]}:ceil;      		.#? N ceil\n  ceiling
{pi*180/}:deg;    	.#? N deg\n  convert deg to rad (180Â° => 3.14..)
{180*pi/}:rad;      .#? N rad\n  convert rad to deg (pi rad => 180)
{mathe\^}:exp;    	.#? N exp\n  exp(x)
{M!}:fact;      		.#? N fact\n  factorial
{.]}:floor;      		.#? N floor\n  floor
{_.]-}:frac;    		.#? N frac\n  fractional part
{1-M!}:gamma;				.#? N gamma\n  gamma function
{2^\2^+Mq}:hypot;   .#? N hypot\n  hypotenuse function
{G}:isprime;        .#? N isprime \n  tests a number for primality
{ML2ML/}:lg;				.#? N lg\n  base-2 log
{Ml}:ln;      			.#? N ln\n  natural log
{ML}:log;      			.#? N log\n  base-10 log
{ML\ML\/}:logn;			.#? N logn\n  base-n log\n ex: log base 6 of 10 written as (10 6logn)
{1-M!MAMl}:lngamma;	.#? N lngamma\n  ln(abs(gamma(x)))
{2:_>?}:smaller;    .#? NN smaller\n  choose smaller
{2:_<?}:bigger;     .#? NN bigger\n  choose bigger
{{2:_<?}U}:max;     .#? L max\n  max value of a list
{{2:_>?}U}:min;     .#? L min\n  min value of a list
{%}:mod;            .#? N mod\n  modulo
{_#2^SMq#/}:normal; .#? L<N> normal\n  compute the normal vector of the given list
{Mp}:primes;        .#? N primes\n  returns a list containing the primes up to and including N
{{*}U}:product;     .#? L product\n  product of a list
{.!}:signnum;       .#? N signnum \n  returns the sign of a number (1,0,-1)
{Mq}:sqrt;          .#? N sqrt\n  square root
{M$3E/.]}:ts;      .#? ts\n  return the system time in seconds as an int
{/.]}:div;					.#? <NN> div\n  integer division
{%}:rem;						.#? <NN> rem\n  remainder after division
{PE}:numofdigits;   .#? N numofdignts\n  number of digits in N

.# Additional Math Functions

.#? NN lcm\n least common multiple of two numbers or a list of numbers
{_{{.-}U}{.-}@'Nisa?}:lcm;

.#? NN gcd \n  greatest common divisior of 2 numbers or a list of numbers
{_{{.+}U}{.+}@'Nisa?}:gcd;


.#? N factors \n  returns a list of the numbers factors
{n, [1 n,, n\%0=]}:divisors;

.#? L geomean \n  geometric mean
.# the nth root of the product of n numbers
{_E\{*}U1@/^}:geomean;

.#? L median \n  median value of a list
{l,
  l$_E2/.]               .# Sort the list and get its middle index
  {I} {_1-KIS2/} lE2%0=?  .# If the list has even length, average the middle two
                          .# The list has odd length, take the middle item
}:median;

.#? L<N> cumsum\n  cumulative summation of a list
{list : sum outlist,
  .# Allocate output list
  0 listE L :outlist;

  for 'i (list irange) {
    list iI sum + : sum;
    sum outlist i D
  };

  outlist
}:cumsum;

.#? L<N> cumprod\n  cumulative product of a list
{list : prod outlist,
  .# Initialize prod
  1:prod;

  .# Allocate output list
  0 listE L :outlist;

  for 'i (list irange) {
    list iI prod * : prod;
    prod outlist i D
  };

  outlist
}:cumprod;

.#? LL pearson\n  pearson correlation coefficient between 2 datasets
{x y : n xs ys,
  xE:n;
  xS:xs;
  yS:ys;

  [x y,*]Sn* xs ys*-
   x2#^Sn* xs2^ -
   y2#^Sn* ys2^ -
   * Mq
  /
}:pearson;

.#? N factors\n  compute a number's prime factors
.# golf: {n,{2to(nV){n\%0=}.NI_n\/fK}{n}nGn2<|?}:f;
{n,
  .# If the number is not prime, find the
  .#   next factor
  {
    .# Range from 2..ceil(sqrt(n))
    [2nVMq.[]R

    .# Find the next factor
    {n\%0=}.N

    .# Append this factor to the list of
    .#   factors recursively
    I _n\/ factors K
  }
  .# If the number is prime, return it
  {n} nG n2< | ?
}:factors;


.# Trigonometry

{Ms}:sin;                   .#? N sin \n  sine
{Mc}:cos;                   .#? N cos \n  cosine
{Mt}:tan;       			      .#? N tan \n  tangent
{Ms1\/}:csc;                .#? N csc \n  cosecant
{Mc1\/}:sec;                .#? N sec \n  secant
{Mt1\/}:cot;                .#? N cot \n  cotangent

{MS}:asin;                  .#? N asin \n  inverse sine
{MC}:acos;                  .#? N acos \n  inverse cosine
{MT}:atan;                  .#? N atan \n  inverse tangent
{1\/MS}:acsc;               .#? N acsc \n  inverse cosecant
{1\/MC}:asec;               .#? N asec \n  inverse secant
{1\/MT}:acot;               .#? N acot \n  inverse cotangent

{_exp\!exp-2/}:sinh;        .#? N sinh \n  hyperbolic sine
{_exp\!exp+2/}:cosh;        .#? N cosh \n  hyperbolic cosine
{_sinh\cosh/}:tanh;         .#? N tanh \n  hyperbolic tangent
{sinh1\/}:csch;             .#? N csch \n  hyperbolic cosecant
{cosh1\/}:sech;             .#? N sech \n  hyperbolic secant
{tanh1\/}:coth;             .#? N coth \n  hyperbolic cotangent

{_2^1+Mq+Ml}:asinh;             .#? N asinh \n  inverse hyperbolic sine
{__1-Mq\1+Mq*+Ml}:acosh;        .#? N acosh \n  inverse hyperbolic cosine
{_1\+Ml\1\-Ml-0.5*}:atanh;      .#? N atanh \n  inverse hyperbolic tangent
{_1\/\2^1\/1+Mq+Ml}:acsch;      .#? N acsch \n  inverse hyperbolic cosecant
{1\/__1+Mq\1-Mq*+Ml}:asech;    	.#? N asech \n  inverse hyperbolic secant
{1\/_1\-Ml\1+Ml\-0.5*}:acoth;  	.#? N acoth \n  inverse hyperbolic cotangent


.# Combinatorics

{`({n r, nM! n r-M!/})}:npr;        .# Permutations (nPr) (infix operator)
{`({n r, nM! n r- M!/ rM!/})}:ncr;  .# Combinations (nCr) (infix operator)

.# Bits
{2 10 H}:unbit;   .#? L unbit \n  convert a list of bits to a number
{10 2 H}:bits;    .#? N bits \n  convert a positive number to a list of bits
{10 16 H}:hex;    .#? N hex\n  convert an int into a hex string
{16 10 H}:unhex;  .#? S unhex\n  convert a hex string to an int



.# Plotting

{.X}:plot;
[10!_0.1+10]R:plotrange:pr;             .#? plotrange pr \n  a range from -10 to 10 at 0.1 increments
{fE,[10!_.01+10,f].X}:quickplot;        .#? E quickplot qp \n  plots an expression on the testplot range
{fE,[10!_.01+10,f,0=!].X}:plotnozero;   .#? E plotnozero \n  same as plot but with no zero (avoids div by zero error)
{_2!E+}:dy:ddelta;                      .#? N dt or \{delta} \n  copies the value and adds one-hundredth\n ex: [0dt1,Ms].X
{2!E+}:dx;                              .#? N dx \n  adds one one-hundredth to the value

.# Statistics
{set : m, set avg:m; set#{m-2^}S setE /}:variance;
{variance Mq}:stdev;

.#? xL xL regression\n  return a block that evaluates to the regression of the sets
{x y :
  n a b
  sumy sumx
  sumxsq
  sumxytimes,

  xE:n;
  x2#^S:sumxsq;
  [x y,*]S:sumxytimes;
  xS:sumx;
  yS:sumy;


  sumy sumxsq *  sumx sumxytimes * -
  n sumxsq * sumx2^ -
  /:a;

  n sumxytimes * sumx sumy * -
  n sumxsq * sumx2^-
  /:b;

  "{($b)*($a)+}"~
}:regression;

.# Constants

0_/:nan;    .#? nan \n  not a number double literal
1 0/:inf;   .#? inf \n  infinity double literal
1 0/!:minf; .#? minf \n  minus infinity double literal

.# Vector
{[2|,*]S}:bullet:dot; .#? dot\n dot (scalar) product of two lists
