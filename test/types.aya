"running types test":P

list type :@ 1 :!

list :T type :!

[[num]list T]list T:x;
[[num]list]list T :y;

x y :!

[[1 2][3 4]] x :@ 1 :!
[[1 2][3 4]] y :@ 1 :!

1  any  :@ 1 :!
"" any :@ 1 :!

1  ${a::any, a}~ :!
"" ${a::any, a}~ :!

.# basic types
"" str :@ 1 :!
1 str  :@ 0 :!


.# basic lists
[1 2 3] list :@ 1:!
[1 2 3] [any]listT :@ 1:!
[1 2 3] [num]listT :@ 1:!
[1 2 'c] [num]listT :@ 0:!


.# .# nested lists
[[1 2][3 4]] [[num]list]listT :@ 1 :!
[[1 2][3 4]] [list]listT :@ 1 :!
[[1 2][3 4]] [any]listT :@ 1 :!
[[1 2][3 4]] list :@ 1 :!
[[1 2]['c "d"]] [[num]list]listT :@ 0 :!
[[1 2]['c "d"]] [[any]list]listT :@ 1 :!
[[1 2]['c "d"]] [list]listT :@ 1 :!
[[1 2]['c "d"]] [any]listT :@ 1 :!
[[1 2]['c "d"]] [num]listT :@ 0 :!
[[1 2]['c "d"]] list :@ 1 :!

.# .# empty lists (always true)
[] [[num]list]listT :@ 1 :!
[] [[any]list]listT :@ 1 :!
[] [list]listT :@ 1 :!
[] [any]listT :@ 1 :!
[] [num]listT :@ 1 :!
[] list :@ 1 :!


.# .# unions
"" [str num]unionT :@ 1 :!
1 [str num]unionT :@ 1 :!
'c [str num]unionT :@ 0 :!
"" [str]unionT :@ 1 :!
1 [str]unionT :@ 0 :!

1 ${a::[str num]union, a}~ :!

1 2 {a::[str num]union b, a b +}~ 3 :!

.# .# list/union combinations
[1 2 'c] [[num char]union]listT :@ 1 :!
1 [[num]list num]unionT :@ 1 :!
[1 2 3] [[num]list num]unionT :@ 1 :!
1 [[num]list num]unionT :@ 1 :!

.# .# dict
:{1:a} dict :@ 1 :!
:{1:a} [num]dictT :@ 1 :!
:{1:a} [str]dictT :@ 0 :!


struct foo {x} ;

.# new type format
def foo::__type__ :{
    ::foo:name;
    type.__meta__ :__meta__;
}



0 foo! foo :@ 1 :!
"foo" foo :@ 0 :!
foo type :@ 1 :!


struct point {x y} ;


.# new type format
def point::__type__ :{
    ::point:name;
    type.__meta__ :__meta__;
}

def point::__type_check__ {value inner self : inner_type, 
    inner.[0] :inner_type;

    value.x inner_type :@
    value.y inner_type :@
    &
}

1 2 point! point :@ 1 :!
"a" "b" point! point :@ 1 :!
1 2 point! [num]pointT :@ 1 :!
"a" "b" point! [num]pointT :@ 0 :!

point type :@ 1 :!


struct pair {first second} ;

def pair::__type__ :{
    ::pair :name;
    type.__meta__ :__meta__;
}

def pair::__type_check__ {value inner self,
    value.first  inner.[0] :@
    value.second inner.[1] :@
    &
}

1 2 pair! pair :@ 1 :!
1 "a" pair! pair :@ 1 :!
1 1 pair! [num num]pairT :@ 1 :!
1 "a" pair! [num str]pairT :@ 1 :!
1 1 pair! [str str]pairT :@ 0 :!
1 "a" pair! [str num]pairT :@ 0 :!

struct optional {value valid} ;

def optional::__type__ :{
    ::optional :name;
    type.__meta__ :__meta__;
}

def optional::__type_check__ {value inner self,
    value.valid {
        value.value inner.[0] :@
    } {
        .# if empty, we don't care what the value is
        1
    } .?
}

"value" 1 optional! optional :@ 1 :!
"value" 1 optional! [str]optionalT :@ 1 :!
"value" 0 optional! [str]optionalT :@ 1 :!
.# invalid, we don't care what the inner type is
::value 0 optional! [str]optionalT :@ 1 :!
.# valid, we DO care what the inner type is
::value 1 optional! [str]optionalT :@ 0 :!
0 0 optional! [str]optionalT :@ 1 :!


((0 0 point!, 0 0 point!)pair!, 1)optional! [[[num]point [num]point]pair]optionalT :@ 1 :!
((0 "nope" point!, 0 0 point!)pair!, 1)optional! [[[num]point [num]point]pair]optionalT :@ 0 :!

"done" :P
