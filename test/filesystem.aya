.# Run inside aya directory
.#
.# cd path/to/aya
.# rm -rf fs_test
.# mkdir fs_test
.# java -jar aya.jar fs_test/ ../test/filesystem.aya

require image {image}

.{ Function that appends the platform-specific file separator to a string .}
{path::str, path :9s + } :sep;

.# Create a directory
"dir1" :(sys.mkdir)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test

.# Change working directory
"dir1" :(sys.cd)
"dir2" :(sys.mkdir)
{"." :(sys.readdir) ["dir2"sep] = 1} test.test

".." :(sys.cd)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test

"../../" :(sys.set_ad)
"../" :(sys.cd)
{"fs_test" :(sys.readdir) ["dir1"sep] = 1} test.test

.# Set aya dir back to normal
"." :(sys.set_ad)
"fs_test" :(sys.cd)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test
"dir1" :(sys.cd)
{"." :(sys.readdir) ["dir2"sep] = 1} test.test

.# Return to aya dir
"" :(sys.cd)
.# Go into fs_test dir
"fs_test" :(sys.cd)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test

.# cd into nested directory
"dir1/dir2/" :(sys.cd)
{"." :(sys.readdir) [] = 1} test.test
"../.." :(sys.cd)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test


.# Write a file
"hello.txt" 'w :(fstream.O) :id;
{"Hello!" id :(fstream.O) 1} test.test
{id 'c :(fstream.O) 1} test.test
.# Use C to sort lists when checking if they are equal
{"." :(sys.readdir)C ["dir1"sep "hello.txt"]C = 1} test.test

.# Read a file
"hello.txt" 'r :(fstream.O) :id;
{id 'a :(fstream.O) "Hello!"} test.test
{id 'c :(fstream.O) 1} test.test


.# Write a file in a directory
"dir1/two-plus-two.txt" 'w :(fstream.O) :id;
{"four" id :(fstream.O) 1} test.test
{id 'c :(fstream.O) 1} test.test
.# Use C to sort lists when checking if they are equal
{"." :(sys.readdir)C ["dir1"sep "hello.txt"]C = 1} test.test
{"dir1/" :(sys.readdir)C ["dir2"sep "two-plus-two.txt"]C = 1} test.test

.# Read a file in a directory
"dir1/two-plus-two.txt" 'r :(fstream.O) :id;
{id 'a :(fstream.O) "four"} test.test
{id 'c :(fstream.O) 1} test.test

.# Create a directory in a directory
"dir1/dir2/dir3" :(sys.mkdir)
{"dir1/dir2" :(sys.readdir) ["dir3"sep] = 1} test.test

.# Create a single pixel image
:{ 1:width 1:height [41]:r [164]:g [34]:b }:img;
img "out.png" :(image.write)
{"." :(sys.readdir)C ["dir1"sep "hello.txt" "out.png"]C = 1} test.test

.# Read an image
"out.png" image.read :img;
{img.pixels [[41 164 34 255]]} test.test

.# Write bytes to a file
[0 -1 255 -128 128 -192 64] "file.bin" 0 .G
.# Append a byte to a file
192 "file.bin" 1 .G
.# Append a character to a file
'a "file.bin" 1 .G

.# Read bytes from a file
{
    "file.bin" :(fileutils.readallbytes) :0xff &
    [0 -1 255 -128 128 -192 64 192 ('a :')] :0xff &
} test.test

.# Move a file
{
    [1 2 3] "file1.bin" 0 .G

    "file1.bin" "file2.bin" :(sys.mv)

    "file1.bin" :(sys.isfile) 0 :!
    "file2.bin" :(sys.isfile) 1 :!
    "file2.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

.# Copy a file
{
    .# relies on file1/file2 from the previous test
    "file1.bin" :(sys.isfile) 0 :!
    [4 5 6] "file2.bin" 0 .G

    "file2.bin" "file1.bin" :(sys.cp)
    "file1.bin" :(sys.isfile) 1 :!
    "file2.bin" :(sys.isfile) 1 :!
    "file1.bin" :(fileutils.readallbytes) :0xff & [4 5 6] :!
    "file2.bin" :(fileutils.readallbytes) :0xff & [4 5 6] :!
}~

.# Move a directory with :(sys.mv) (instead of with sys.mvdir)
{
    "dir4" :(sys.isdir) 0 :!
    "dir5" :(sys.isdir) 0 :!
    
    "dir4" :(sys.mkdir)
    [1 2 3] "dir4/file1.bin" 0 .G
    
    "dir4" "dir5" :(sys.mv)
    
    "dir4" :(sys.isdir) 0 :!
    "dir5" :(sys.isdir) 1 :!
    "dir5" :(sys.readdir)E 1 :!
    "dir5/file1.bin" :(sys.isfile) 1 :!
    "dir5/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

.# Copy a directory
{
    .# relies on dir4/dir5 from the previous test
    "dir4" :(sys.isdir) 0 :!
    "dir5" :(sys.isdir) 1 :!

    "dir5" "dir4" :(sys.cp)
    
    "dir4" :(sys.isdir) 1 :!
    "dir5" :(sys.isdir) 1 :!
    "dir4" :(sys.readdir)E 1 :!
    "dir5" :(sys.readdir)E 1 :!
    "dir4/file1.bin" :(sys.isfile) 1 :!
    "dir4/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
    "dir5/file1.bin" :(sys.isfile) 1 :!
    "dir5/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

{blk::block,
    .# use evaluation in list to obtain a separate stack
    [{blk} {;::__fail} .K] [::__fail] =! {
        "assertfail: code $(blk.`) should have failed but did not" .D
    }?
}:assertfail;

.# verify that illegal and destructive operations are rejected by sys.mv and sys.cp
{
    "dir6" :(sys.mkdir)
    "dir6/dir7" :(sys.mkdir)
    "dir6/dir7/dir8" :(sys.mkdir)
	"dir6/dir9" :(sys.mkdir)
    "dir6/dir9/dir10" :(sys.mkdir)
    [1 2 3] "dir6/file" 0 .G
	[4 5 6] "dir6/file2" 0 .G
    
    {
        "dir6" :(sys.isdir) 1 :!
        "dir6/dir7" :(sys.isdir) 1 :!
        "dir6/dir7/dir8" :(sys.isdir) 1 :!
		"dir6/dir9" :(sys.isdir) 1 :!
        "dir6/dir9/dir10" :(sys.isdir) 1 :!
        "dir6/file" :(sys.isfile) 1 :!
		"dir6/file2" :(sys.isfile) 1 :!
		"dir6" :(sys.readdir)E 4 :!
		"dir6/dir7" :(sys.readdir)E 1 :!
		"dir6/dir7/dir8" :(sys.readdir)E 0 :!
		"dir6/dir9" :(sys.readdir)E 1 :!
		"dir6/dir9/dir10" :(sys.readdir)E 0 :!
    }:verify_files;
	
.# Block mv/cp where the destination exists
	["dir6/file" "dir6/dir7/dir8" "dir6/dir7"] .# sources (existing [file empty-dir non-empty-dir])
	["dir6/file2" "dir6/dir9/dir10" ("./" "dir6" "dir6/dir9")] .# destinations (existing [file empty-dir non-empty-dir]), note that these are different from the source files
	{src dst,
		{ src dst :(sys.mv) } assertfail verify_files
		{ src dst :(sys.cp) } assertfail verify_files
	} :*;

.# Block mv/cp of directories into themselves
    .# (outer inner mv) : this is an impossible operation (dir6 would have no parent)
    { "dir6" "dir6/foo" :(sys.mv) } assertfail verify_files
    { "dir6" "dir6/dir7" :(sys.mv) } assertfail verify_files
    { "dir6" "dir6/dir7/dir8" :(sys.mv) } assertfail verify_files
    { "dir6" "dir6/file" :(sys.mv) } assertfail verify_files
    { "./" "dir6" :(sys.mv) } assertfail verify_files
    
    .# (outer inner cp)
    .# this is somewhat risky: if the request is not rejected this will create directories until a stackoverflow is reached..
    .# currently sys.mv and sys.cp share the same sanity checks, so it should be safe. (the above checks would fail first)
    { "dir6" "dir6/foo" :(sys.cp) } assertfail verify_files
    { "dir6" "dir6/dir7" :(sys.cp) } assertfail verify_files
    { "dir6" "dir6/dir7/dir8" :(sys.cp) } assertfail verify_files
    { "dir6" "dir6/file" :(sys.cp) } assertfail verify_files
    { "./" "dir6" :(sys.cp) } assertfail verify_files
}~
