.# Run inside aya directory
.#
.# cd path/to/aya
.# rm -rf fs_test
.# mkdir fs_test
.# java -jar aya.jar fs_test/ ../test/filesystem.aya

require image {image}

.{ Function that appends the platform-specific file separator to a string .}
{path::str, path :9s + } :sep;

.# Create a directory
"dir1" :(sys.mkdir)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test

.# Change working directory
"dir1" :(sys.cd)
"dir2" :(sys.mkdir)
{"." :(sys.readdir) ["dir2"sep] = 1} test.test

".." :(sys.cd)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test

"../../" :(sys.set_ad)
"../" :(sys.cd)
{"fs_test" :(sys.readdir) ["dir1"sep] = 1} test.test

.# Set aya dir back to normal
"." :(sys.set_ad)
"fs_test" :(sys.cd)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test
"dir1" :(sys.cd)
{"." :(sys.readdir) ["dir2"sep] = 1} test.test

.# Return to aya dir
"" :(sys.cd)
.# Go into fs_test dir
"fs_test" :(sys.cd)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test

.# cd into nested directory
"dir1/dir2/" :(sys.cd)
{"." :(sys.readdir) [] = 1} test.test
"../.." :(sys.cd)
{"." :(sys.readdir) ["dir1"sep] = 1} test.test


.# Write a file
"hello.txt" 'w :(fstream.O) :id;
{"Hello!" id :(fstream.O) 1} test.test
{id 'c :(fstream.O) 1} test.test
.# Use C to sort lists when checking if they are equal
{"." :(sys.readdir)C ["dir1"sep "hello.txt"]C = 1} test.test

.# Read a file
"hello.txt" 'r :(fstream.O) :id;
{id 'a :(fstream.O) "Hello!"} test.test
{id 'c :(fstream.O) 1} test.test


.# Write a file in a directory
"dir1/two-plus-two.txt" 'w :(fstream.O) :id;
{"four" id :(fstream.O) 1} test.test
{id 'c :(fstream.O) 1} test.test
.# Use C to sort lists when checking if they are equal
{"." :(sys.readdir)C ["dir1"sep "hello.txt"]C = 1} test.test
{"dir1/" :(sys.readdir)C ["dir2"sep "two-plus-two.txt"]C = 1} test.test

.# Read a file in a directory
"dir1/two-plus-two.txt" 'r :(fstream.O) :id;
{id 'a :(fstream.O) "four"} test.test
{id 'c :(fstream.O) 1} test.test

.# Create a directory in a directory
"dir1/dir2/dir3" :(sys.mkdir)
{"dir1/dir2" :(sys.readdir) ["dir3"sep] = 1} test.test

.# Create a single pixel image
:{ 1:width 1:height [41]:r [164]:g [34]:b }:img;
img "out.png" :(image.write)
{"." :(sys.readdir)C ["dir1"sep "hello.txt" "out.png"]C = 1} test.test

.# Read an image
"out.png" image.read :img;
{img.pixels [[41 164 34 255]]} test.test

.# Write bytes to a file
[0 -1 255 -128 128 -192 64] "file.bin" 0 .G
.# Append a byte to a file
192 "file.bin" 1 .G
.# Append a character to a file
'a "file.bin" 1 .G

.# Read bytes from a file
{
    "file.bin" :(fileutils.readallbytes) :0xff &
    [0 -1 255 -128 128 -192 64 192 ('a :')] :0xff &
} test.test

.# Move a file
{
    [1 2 3] "file1.bin" 0 .G

    "file1.bin" "file2.bin" :(sys.mv)

    "file1.bin" :(sys.isfile) 0 :!
    "file2.bin" :(sys.isfile) 1 :!
    "file2.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

.# Copy a file
{
    .# relies on file1/file2 from the previous test
    "file1.bin" :(sys.isfile) 0 :!
    [4 5 6] "file2.bin" 0 .G

    "file2.bin" "file1.bin" :(sys.cp)
    "file1.bin" :(sys.isfile) 1 :!
    "file2.bin" :(sys.isfile) 1 :!
    "file1.bin" :(fileutils.readallbytes) :0xff & [4 5 6] :!
    "file2.bin" :(fileutils.readallbytes) :0xff & [4 5 6] :!
}~

.# Copy a file replacing the existing file
{
    [1 2 3] "file1.bin" 0 .G
    [4 5 6] "file2.bin" 0 .G

    "file1.bin" "file2.bin" :(sys.cp)

    "file1.bin" :(sys.isfile) 1 :!
    "file2.bin" :(sys.isfile) 1 :!
    "file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
    "file2.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

.# Move a file replacing the existing file
{
    [1 2 3] "file1.bin" 0 .G
    [4 5 6] "file2.bin" 0 .G

    "file1.bin" "file2.bin" :(sys.mv)
    
    "file1.bin" :(sys.isfile) 0 :!
    "file2.bin" :(sys.isfile) 1 :!
    "file2.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

.# Move a directory with :(sys.mv) (instead of with sys.mvdir)
{
    "dir4" :(sys.isdir) 0 :!
    "dir5" :(sys.isdir) 0 :!
    
    "dir4" :(sys.mkdir)
    [1 2 3] "dir4/file1.bin" 0 .G
    
    "dir4" "dir5" :(sys.mv)
    
    "dir4" :(sys.isdir) 0 :!
    "dir5" :(sys.isdir) 1 :!
    "dir5" :(sys.readdir)E 1 :!
    "dir5/file1.bin" :(sys.isfile) 1 :!
    "dir5/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

.# Move a directory replacing an existing directory with :(sys.mv)
{
    .# relies on dir4/dir5 from the previous test
    "dir4" :(sys.isdir) 0 :!
    "dir5" :(sys.isdir) 1 :!
    
    "dir4" :(sys.mkdir)
    "dir5" "dir4" :(sys.mv) .# move onto empty directory
    "dir4" :(sys.isdir) 1 :!
    "dir5" :(sys.isdir) 0 :!
    "dir4" :(sys.readdir)E 1 :!
    "dir4/file1.bin" :(sys.isfile) 1 :!
    "dir4/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
    
    "dir5" :(sys.mkdir)
    [4 5 6] "dir5/file2.bin" 0 .G
    "dir4" "dir5" :(sys.mv) .# move onto non-empty directory
    "dir4" :(sys.isdir) 0 :!
    "dir5" :(sys.isdir) 1 :!
    "dir5" :(sys.readdir)E 1 :!
    "dir5/file1.bin" :(sys.isfile) 1 :!
    "dir5/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

.# Copy a directory
{
    .# relies on dir4/dir5 from the previous test
    "dir4" :(sys.isdir) 0 :!
    "dir5" :(sys.isdir) 1 :!

    "dir5" "dir4" :(sys.cp)
    
    "dir4" :(sys.isdir) 1 :!
    "dir5" :(sys.isdir) 1 :!
    "dir4" :(sys.readdir)E 1 :!
    "dir5" :(sys.readdir)E 1 :!
    "dir4/file1.bin" :(sys.isfile) 1 :!
    "dir4/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
    "dir5/file1.bin" :(sys.isfile) 1 :!
    "dir5/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
    
    .# Copy a directory replacing an existing non-empty directory
    [4 5 6] "dir5/file2.bin" 0 .G
    "dir4" "dir5" :(sys.cp)
    "dir4" :(sys.isdir) 1 :!
    "dir5" :(sys.isdir) 1 :!
    "dir4" :(sys.readdir)E 1 :!
    "dir5" :(sys.readdir)E 1 :!
    "dir4/file1.bin" :(sys.isfile) 1 :!
    "dir4/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
    "dir5/file1.bin" :(sys.isfile) 1 :!
    "dir5/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
    
    .# Copy a directory replacing an existing empty directory
    "dir5" :(sys.rm)
    "dir5" :(sys.mkdir)
    "dir4" "dir5" :(sys.cp)
    "dir4" :(sys.isdir) 1 :!
    "dir5" :(sys.isdir) 1 :!
    "dir4" :(sys.readdir)E 1 :!
    "dir5" :(sys.readdir)E 1 :!
    "dir4/file1.bin" :(sys.isfile) 1 :!
    "dir4/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
    "dir5/file1.bin" :(sys.isfile) 1 :!
    "dir5/file1.bin" :(fileutils.readallbytes) :0xff & [1 2 3] :!
}~

.# sys.mv and sys.cp for (file directory) or (directory file)
{
    .# relies on dir4/dir5 from the previous test
    "dir4" :(sys.isdir) 1 :!
    "dir5" :(sys.isdir) 1 :!
    [7 8 9] "file.bin" 0 .G
    
    .# sys.mv (file dir)
    "file.bin" "dir4" :(sys.mv)
    "file.bin" :(sys.isfile) 0 :!
    "file.bin" :(sys.isdir) 0 :!
    "dir4" :(sys.isfile) 1 :!
    
    .# sys.mv (dir file)
    "dir5" "file.bin" :(sys.mv)
    "dir5" :(sys.isfile) 0 :!
    "dir5" :(sys.isdir) 0 :!
    "file.bin" :(sys.isdir) 1 :!
    
    .# restore the initial state because the names will be confusing otherwise.
    ["dir4" "dir5"] {d,
        d :(sys.exists) { d :(sys.rm) }?
        d :(sys.mkdir)
    }O;
    "file.bin" :(sys.rm)
    [7 8 9] "file.bin" 0 .G
    [1 2 3] "dir4/file1.bin" 0 .G
    [4 5 6] "dir5/file2.bin" 0 .G
    
    .# sys.cp (file dir)
    "file.bin" "dir4" :(sys.cp)
    "file.bin" :(sys.isfile) 1 :!
    "dir4" :(sys.isfile) 1 :!
    
    .# sys.mv (dir file)
    "dir5" "file.bin" :(sys.cp)
    "dir5" :(sys.isdir) 1 :!
    "file.bin" :(sys.isdir) 1 :!
}~

{blk::block,
    .# use evaluation in list to obtain a separate stack
    [{blk} {;::__fail} .K] [::__fail] =! {
        "assertfail: code $(blk.`) should have failed but did not" .D
    }?
}:assertfail;

.# Block mv/cp of directories into themselves
{
    "dir6" :(sys.mkdir)
    "dir6/dir7" :(sys.mkdir)
    "dir6/dir7/dir8" :(sys.mkdir)
    [1 2 3] "dir6/file" 0 .G
    
    {
        "dir6" :(sys.isdir) 1 :!
        "dir6/dir7" :(sys.isdir) 1 :!
        "dir6/dir7/dir8" :(sys.isdir) 1 :!
        "dir6/file" :(sys.isfile) 1 :!
    }:verify_files;

    .# (outer inner mv) : this is an impossible operation (dir6 would have no parent)
    { "dir6" "dir6/foo" :(sys.mv) } assertfail verify_files
    { "dir6" "dir6/dir7" :(sys.mv) } assertfail verify_files
    { "dir6" "dir6/dir7/dir8" :(sys.mv) } assertfail verify_files
    { "dir6" "dir6/file" :(sys.mv) } assertfail verify_files
    { "./" "dir6" :(sys.mv) } assertfail verify_files
    
    .# (inner outer mv) : this is an undesirable operation (inner files replacing the outer directory)
    { "dir6/file" "dir6/" :(sys.mv) } assertfail verify_files
    { "dir6/dir7" "dir6/" :(sys.mv) } assertfail verify_files
    { "dir6/dir7/dir8" "dir6/" :(sys.mv) } assertfail verify_files
    { "dir6/dir7/dir8" "dir6/dir7" :(sys.mv) } assertfail verify_files
    { "dir6/file" "./" :(sys.mv) } assertfail verify_files

    .# (outer inner cp)
    .# this is somewhat risky: if the request is not rejected this will create directories until a stackoverflow is reached..
    .# currently sys.mv and sys.cp share the same sanity checks, so it should be safe. (the above checks would fail first)
    { "dir6" "dir6/foo" :(sys.cp) } assertfail verify_files
    { "dir6" "dir6/dir7" :(sys.cp) } assertfail verify_files
    { "dir6" "dir6/dir7/dir8" :(sys.cp) } assertfail verify_files
    { "dir6" "dir6/file" :(sys.cp) } assertfail verify_files
    { "./" "dir6" :(sys.cp) } assertfail verify_files
    
    .# (inner outer cp)
    { "dir6/file" "dir6/" :(sys.cp) } assertfail verify_files
    { "dir6/dir7" "dir6/" :(sys.cp) } assertfail verify_files
    { "dir6/dir7/dir8" "dir6/" :(sys.cp) } assertfail verify_files
    { "dir6/dir7/dir8" "dir6/dir7" :(sys.cp) } assertfail verify_files
    { "dir6/file" "./" :(sys.cp) } assertfail verify_files
}~
